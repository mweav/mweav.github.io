<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Nominalish — Nominalish Graphs</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/agda.css" />
</head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Nominalish</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Nominalish Graphs</h1>

            <div class="post">
    Posted on September 12, 2015
    
        by Matthew Weaver
    
</div>

<p>Graphs are a difficult data structure to represent in a natural and usable way. In particular, deriving a definition such that its equality matches that of graph equality is quite challenging on its own, let alone a definition that additionally permits induction over the number of vertices and edges. However, assume there is a type for (finite) sets that allows for induction over their size. Then, given some (finite) set <code>V</code>, a (finite) graph over the set <code>V</code> can be defined as the set <code>V × E</code>, where <code>E ⊆ V × V</code>. This both matches the formulation used in mathematics, and would have the desired properties described previously. Thus, we conclude with the following question: “How does one define such a formulation of sets?”</p>
<!--more-->
<p>Before getting to finite sets, let’s first consider multisets. Intuitively, a multises is the quotient of a list that “forgets” the order of its elements. In other words, all permuatations of the list are considered equal. Immedietly, the use of the term “permutation” elicits a potential connection to nominal sets, so let’s see if we can draw it explicitly.</p>
<pre class="Agda"><code><a name="1182"></a><a name="1197" class="Keyword">module</a><a name="1203"> </a><a name="1204" href="#1" class="Module">graphs</a><a name="1210"> </a><a name="1211" class="Keyword">where</a></code></pre>
<p>I am building my code off of Pritam Choudhury’s <a href="http://www.cl.cam.ac.uk/~amp12/agda/choudhury/html/README.html">Agda library</a> for nominal sets.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<pre class="Agda"><code><a name="1595"></a><a name="1611" class="Keyword">open</a><a name="1615"> </a><a name="1616" class="Keyword">import</a><a name="1622"> </a><a name="1623" class="Module">Nominal</a></code></pre>
<p>First, in order to encode multisets, I define what I call “coNominal Sets.” Instead of being finitely supported, they are finitely cosupported; in other words, there are only finitely many atoms that can be included in swaps.</p>
<pre class="Agda"><code><a name="1868"></a><a name="1883" class="Keyword">data</a><a name="1887"> </a><a name="1888" href="#1888" class="Datatype Operator">_∈_</a><a name="1891"> </a><a name="1892" class="Symbol">(</a><a name="1893" href="#1893" class="Bound">a</a><a name="1894"> </a><a name="1895" class="Symbol">:</a><a name="1896"> </a><a name="1897" class="Datatype">Atom</a><a name="1901" class="Symbol">)</a><a name="1902"> </a><a name="1903" class="Symbol">:</a><a name="1904"> </a><a name="1905" class="Datatype">List</a><a name="1909"> </a><a name="1910" class="Datatype">Atom</a><a name="1914"> </a><a name="1915" class="Symbol">→</a><a name="1916"> </a><a name="1917" class="PrimitiveType">Set</a><a name="1920"> </a><a name="1921" class="Keyword">where</a><a name="1926">
  </a><a name="1929" href="#1929" class="InductiveConstructor">a∈a::l</a><a name="1935"> </a><a name="1936" class="Symbol">:</a><a name="1937"> </a><a name="1938" class="Symbol">∀</a><a name="1939"> </a><a name="1940" class="Symbol">{</a><a name="1941" href="#1941" class="Bound">as</a><a name="1943" class="Symbol">}</a><a name="1944"> </a><a name="1945" class="Symbol">→</a><a name="1946"> </a><a name="1947" href="#1893" class="Bound">a</a><a name="1948"> </a><a name="1949" href="#1888" class="Datatype Operator">∈</a><a name="1950"> </a><a name="1951" class="Symbol">(</a><a name="1952" href="#1893" class="Bound">a</a><a name="1953"> </a><a name="1954" class="InductiveConstructor Operator">::</a><a name="1956"> </a><a name="1957" href="#1941" class="Bound">as</a><a name="1959" class="Symbol">)</a><a name="1960">
  </a><a name="1963" href="#1963" class="InductiveConstructor">a∈as</a><a name="1967">   </a><a name="1970" class="Symbol">:</a><a name="1971"> </a><a name="1972" class="Symbol">∀</a><a name="1973"> </a><a name="1974" class="Symbol">{</a><a name="1975" href="#1975" class="Bound">b</a><a name="1976"> </a><a name="1977" href="#1977" class="Bound">as</a><a name="1979" class="Symbol">}</a><a name="1980"> </a><a name="1981" class="Symbol">→</a><a name="1982"> </a><a name="1983" href="#1893" class="Bound">a</a><a name="1984"> </a><a name="1985" href="#1888" class="Datatype Operator">∈</a><a name="1986"> </a><a name="1987" href="#1977" class="Bound">as</a><a name="1989"> </a><a name="1990" class="Symbol">→</a><a name="1991"> </a><a name="1992" href="#1893" class="Bound">a</a><a name="1993"> </a><a name="1994" href="#1888" class="Datatype Operator">∈</a><a name="1995"> </a><a name="1996" class="Symbol">(</a><a name="1997" href="#1975" class="Bound">b</a><a name="1998"> </a><a name="1999" class="InductiveConstructor Operator">::</a><a name="2001"> </a><a name="2002" href="#1977" class="Bound">as</a><a name="2004" class="Symbol">)</a><a name="2005">

</a><a name="2007" class="Keyword">record</a><a name="2013"> </a><a name="2014" href="#2014" class="Record">coNominal</a><a name="2023"> </a><a name="2024" class="Symbol">:</a><a name="2025"> </a><a name="2026" class="PrimitiveType">Set₁</a><a name="2030"> </a><a name="2031" class="Keyword">where</a><a name="2036">
  </a><a name="2039" class="Keyword">field</a><a name="2044"> 
    </a><a name="2050" href="#2050" class="Field">Aˢ</a><a name="2052"> </a><a name="2053" class="Symbol">:</a><a name="2054"> </a><a name="2055" class="PrimitiveType">Set</a><a name="2058">
    </a><a name="2063" href="#2063" class="Field">≈ᵃ</a><a name="2065"> </a><a name="2066" class="Symbol">:</a><a name="2067"> </a><a name="2068" class="Function">Rel</a><a name="2071"> </a><a name="2072" href="#2050" class="Bound">Aˢ</a><a name="2074">
    </a><a name="2079" href="#2079" class="Field">eq≈ᵃ</a><a name="2083"> </a><a name="2084" class="Symbol">:</a><a name="2085"> </a><a name="2086" class="Record">isEquivalence</a><a name="2099"> </a><a name="2100" href="#2050" class="Bound">Aˢ</a><a name="2102"> </a><a name="2103" href="#2063" class="Bound">≈ᵃ</a><a name="2105">
    </a><a name="2110" href="#2110" class="Field">coAct</a><a name="2115"> </a><a name="2116" class="Symbol">:</a><a name="2117"> </a><a name="2118" class="Function">Perm</a><a name="2122"> </a><a name="2123" class="Symbol">→</a><a name="2124"> </a><a name="2125" href="#2050" class="Bound">Aˢ</a><a name="2127"> </a><a name="2128" class="Symbol">→</a><a name="2129"> </a><a name="2130" href="#2050" class="Bound">Aˢ</a><a name="2132">
    </a><a name="2137" href="#2137" class="Field">coRes</a><a name="2142"> </a><a name="2143" class="Symbol">:</a><a name="2144"> </a><a name="2145" href="#2110" class="Bound">coAct</a><a name="2150"> </a><a name="2151" class="Function Operator">Preserves₂</a><a name="2161"> </a><a name="2162" class="Function">pEquiv</a><a name="2168"> </a><a name="2169" class="Function Operator">⟶</a><a name="2170"> </a><a name="2171" href="#2063" class="Bound">≈ᵃ</a><a name="2173"> </a><a name="2174" class="Function Operator">⟶</a><a name="2175"> </a><a name="2176" href="#2063" class="Bound">≈ᵃ</a><a name="2178">
    </a><a name="2183" href="#2183" class="Field">cop₁p₂↠</a><a name="2190"> </a><a name="2191" class="Symbol">:</a><a name="2192"> </a><a name="2193" class="Function">p₁p₂Act</a><a name="2200"> </a><a name="2201" class="Symbol">{</a><a name="2202" class="Function">Perm</a><a name="2206" class="Symbol">}{</a><a name="2208" href="#2050" class="Bound">Aˢ</a><a name="2210" class="Symbol">}{</a><a name="2212" class="Function Operator">_++_</a><a name="2216" class="Symbol">}{</a><a name="2218" href="#2063" class="Bound">≈ᵃ</a><a name="2220" class="Symbol">}{</a><a name="2222" href="#2110" class="Bound">coAct</a><a name="2227" class="Symbol">}</a><a name="2228">
    </a><a name="2233" href="#2233" class="Field">coι↠</a><a name="2237"> </a><a name="2238" class="Symbol">:</a><a name="2239"> </a><a name="2240" class="Function">ιAct</a><a name="2244"> </a><a name="2245" class="Symbol">{</a><a name="2246" class="Function">Perm</a><a name="2250" class="Symbol">}{</a><a name="2252" href="#2050" class="Bound">Aˢ</a><a name="2254" class="Symbol">}{</a><a name="2256" href="#2063" class="Bound">≈ᵃ</a><a name="2258" class="Symbol">}{</a><a name="2260" href="#2110" class="Bound">coAct</a><a name="2265" class="Symbol">}</a><a name="2266"> </a><a name="2267" class="Function">ι</a><a name="2268">

    </a><a name="2274" href="#2274" class="Field">coSupp</a><a name="2280"> </a><a name="2281" class="Symbol">:</a><a name="2282"> </a><a name="2283" href="#2050" class="Bound">Aˢ</a><a name="2285"> </a><a name="2286" class="Symbol">→</a><a name="2287"> </a><a name="2288" class="Datatype">List</a><a name="2292"> </a><a name="2293" class="Datatype">Atom</a><a name="2297">
    </a><a name="2302" href="#2302" class="Field">coSuppAx</a><a name="2310"> </a><a name="2311" class="Symbol">:</a><a name="2312"> </a><a name="2313" class="Symbol">(</a><a name="2314" href="#2314" class="Bound">a</a><a name="2315"> </a><a name="2316" class="Symbol">:</a><a name="2317"> </a><a name="2318" href="#2050" class="Bound">Aˢ</a><a name="2320" class="Symbol">)</a><a name="2321"> </a><a name="2322" class="Symbol">→</a><a name="2323"> </a><a name="2324" class="Symbol">(</a><a name="2325" href="#2325" class="Bound">b</a><a name="2326"> </a><a name="2327" href="#2327" class="Bound">c</a><a name="2328"> </a><a name="2329" class="Symbol">:</a><a name="2330"> </a><a name="2331" class="Datatype">Atom</a><a name="2335" class="Symbol">)</a><a name="2336"> </a><a name="2337" class="Symbol">→</a><a name="2338"> </a><a name="2339" class="Symbol">(</a><a name="2340" href="#2325" class="Bound">b</a><a name="2341"> </a><a name="2342" href="#1888" class="Datatype Operator">∈</a><a name="2343"> </a><a name="2344" href="#2274" class="Bound">coSupp</a><a name="2350"> </a><a name="2351" href="#2314" class="Bound">a</a><a name="2352" class="Symbol">)</a><a name="2353"> </a><a name="2354" class="Symbol">→</a><a name="2355">
               </a><a name="2371" class="Symbol">(</a><a name="2372" href="#2327" class="Bound">c</a><a name="2373"> </a><a name="2374" href="#1888" class="Datatype Operator">∈</a><a name="2375"> </a><a name="2376" href="#2274" class="Bound">coSupp</a><a name="2382"> </a><a name="2383" href="#2314" class="Bound">a</a><a name="2384" class="Symbol">)</a><a name="2385"> </a><a name="2386" class="Symbol">→</a><a name="2387"> </a><a name="2388" href="#2063" class="Bound">≈ᵃ</a><a name="2390"> </a><a name="2391" class="Symbol">(</a><a name="2392" href="#2110" class="Bound">coAct</a><a name="2397"> </a><a name="2398" class="Function Operator">[</a><a name="2399"> </a><a name="2400" class="Symbol">(</a><a name="2401" href="#2325" class="Bound">b</a><a name="2402"> </a><a name="2403" class="InductiveConstructor Operator">,</a><a name="2404"> </a><a name="2405" href="#2327" class="Bound">c</a><a name="2406" class="Symbol">)</a><a name="2407"> </a><a name="2408" class="Function Operator">]</a><a name="2409"> </a><a name="2410" href="#2314" class="Bound">a</a><a name="2411" class="Symbol">)</a><a name="2412">  </a><a name="2414" href="#2314" class="Bound">a</a><a name="2415">

</a><a name="2417" class="Keyword">open</a><a name="2421"> </a><a name="2422" href="#2014" class="Module">coNominal</a><a name="2431"> </a><a name="2432" class="Keyword">public</a></code></pre>
<p>…and then a bunch of uninteresting but necessary definitions…</p>
<pre class="Agda"><code><a name="2517"></a><a name="2532" class="Keyword">data</a><a name="2536"> </a><a name="2537" href="#2537" class="Datatype Operator">_≤_</a><a name="2540"> </a><a name="2541" class="Symbol">:</a><a name="2542"> </a><a name="2543" class="Datatype">ℕ</a><a name="2544"> </a><a name="2545" class="Symbol">→</a><a name="2546"> </a><a name="2547" class="Datatype">ℕ</a><a name="2548"> </a><a name="2549" class="Symbol">→</a><a name="2550"> </a><a name="2551" class="PrimitiveType">Set</a><a name="2554"> </a><a name="2555" class="Keyword">where</a><a name="2560">
  </a><a name="2563" href="#2563" class="InductiveConstructor">0≤n</a><a name="2566">   </a><a name="2569" class="Symbol">:</a><a name="2570"> </a><a name="2571" class="Symbol">{</a><a name="2572" href="#2572" class="Bound">n</a><a name="2573"> </a><a name="2574" class="Symbol">:</a><a name="2575"> </a><a name="2576" class="Datatype">ℕ</a><a name="2577" class="Symbol">}</a><a name="2578"> </a><a name="2579" class="Symbol">→</a><a name="2580"> </a><a name="2581" class="InductiveConstructor">zero</a><a name="2585"> </a><a name="2586" href="#2537" class="Datatype Operator">≤</a><a name="2587"> </a><a name="2588" href="#2572" class="Bound">n</a><a name="2589">
  </a><a name="2592" href="#2592" class="InductiveConstructor">≤succ</a><a name="2597"> </a><a name="2598" class="Symbol">:</a><a name="2599"> </a><a name="2600" class="Symbol">{</a><a name="2601" href="#2601" class="Bound">m</a><a name="2602"> </a><a name="2603" href="#2603" class="Bound">n</a><a name="2604"> </a><a name="2605" class="Symbol">:</a><a name="2606"> </a><a name="2607" class="Datatype">ℕ</a><a name="2608" class="Symbol">}</a><a name="2609"> </a><a name="2610" class="Symbol">→</a><a name="2611"> </a><a name="2612" href="#2601" class="Bound">m</a><a name="2613"> </a><a name="2614" href="#2537" class="Datatype Operator">≤</a><a name="2615"> </a><a name="2616" href="#2603" class="Bound">n</a><a name="2617"> </a><a name="2618" class="Symbol">→</a><a name="2619"> </a><a name="2620" class="Symbol">(</a><a name="2621" class="InductiveConstructor">succ</a><a name="2625"> </a><a name="2626" href="#2601" class="Bound">m</a><a name="2627" class="Symbol">)</a><a name="2628"> </a><a name="2629" href="#2537" class="Datatype Operator">≤</a><a name="2630"> </a><a name="2631" class="Symbol">(</a><a name="2632" class="InductiveConstructor">succ</a><a name="2636"> </a><a name="2637" href="#2603" class="Bound">n</a><a name="2638" class="Symbol">)</a><a name="2639">

</a><a name="2641" href="#2641" class="Function">dec≤lemma</a><a name="2650"> </a><a name="2651" class="Symbol">:</a><a name="2652"> </a><a name="2653" class="Symbol">∀</a><a name="2654"> </a><a name="2655" class="Symbol">{</a><a name="2656" href="#2656" class="Bound">m</a><a name="2657"> </a><a name="2658" href="#2658" class="Bound">n</a><a name="2659" class="Symbol">}</a><a name="2660"> </a><a name="2661" class="Symbol">→</a><a name="2662"> </a><a name="2663" class="Symbol">(</a><a name="2664" class="InductiveConstructor">succ</a><a name="2668"> </a><a name="2669" href="#2656" class="Bound">m</a><a name="2670" class="Symbol">)</a><a name="2671"> </a><a name="2672" href="#2537" class="Datatype Operator">≤</a><a name="2673"> </a><a name="2674" class="Symbol">(</a><a name="2675" class="InductiveConstructor">succ</a><a name="2679"> </a><a name="2680" href="#2658" class="Bound">n</a><a name="2681" class="Symbol">)</a><a name="2682"> </a><a name="2683" class="Symbol">→</a><a name="2684"> </a><a name="2685" href="#2656" class="Bound">m</a><a name="2686"> </a><a name="2687" href="#2537" class="Datatype Operator">≤</a><a name="2688"> </a><a name="2689" href="#2658" class="Bound">n</a><a name="2690">
</a><a name="2691" href="#2641" class="Function">dec≤lemma</a><a name="2700"> </a><a name="2701" class="Symbol">{</a><a name="2702" class="InductiveConstructor">zero</a><a name="2706" class="Symbol">}</a><a name="2707"> </a><a name="2708" class="Symbol">(</a><a name="2709" href="#2592" class="InductiveConstructor">≤succ</a><a name="2714"> </a><a name="2715" href="#2715" class="Bound">x</a><a name="2716" class="Symbol">)</a><a name="2717"> </a><a name="2718" class="Symbol">=</a><a name="2719"> </a><a name="2720" href="#2715" class="Bound">x</a><a name="2721">
</a><a name="2722" href="#2641" class="Function">dec≤lemma</a><a name="2731"> </a><a name="2732" class="Symbol">{</a><a name="2733" class="InductiveConstructor">succ</a><a name="2737"> </a><a name="2738" href="#2738" class="Bound">m</a><a name="2739" class="Symbol">}</a><a name="2740"> </a><a name="2741" class="Symbol">(</a><a name="2742" href="#2592" class="InductiveConstructor">≤succ</a><a name="2747"> </a><a name="2748" href="#2748" class="Bound">x</a><a name="2749" class="Symbol">)</a><a name="2750"> </a><a name="2751" class="Symbol">=</a><a name="2752"> </a><a name="2753" href="#2748" class="Bound">x</a><a name="2754">

</a><a name="2756" href="#2756" class="Function">dec≤</a><a name="2760"> </a><a name="2761" class="Symbol">:</a><a name="2762"> </a><a name="2763" class="Symbol">(</a><a name="2764" href="#2764" class="Bound">m</a><a name="2765"> </a><a name="2766" href="#2766" class="Bound">n</a><a name="2767"> </a><a name="2768" class="Symbol">:</a><a name="2769"> </a><a name="2770" class="Datatype">ℕ</a><a name="2771" class="Symbol">)</a><a name="2772"> </a><a name="2773" class="Symbol">→</a><a name="2774"> </a><a name="2775" class="Datatype">Dec</a><a name="2778"> </a><a name="2779" class="Symbol">(</a><a name="2780" href="#2764" class="Bound">m</a><a name="2781"> </a><a name="2782" href="#2537" class="Datatype Operator">≤</a><a name="2783"> </a><a name="2784" href="#2766" class="Bound">n</a><a name="2785" class="Symbol">)</a><a name="2786">
</a><a name="2787" href="#2756" class="Function">dec≤</a><a name="2791"> </a><a name="2792" class="InductiveConstructor">zero</a><a name="2796">     </a><a name="2801" class="InductiveConstructor">zero</a><a name="2805">     </a><a name="2810" class="Symbol">=</a><a name="2811"> </a><a name="2812" class="InductiveConstructor">yes</a><a name="2815"> </a><a name="2816" href="#2563" class="InductiveConstructor">0≤n</a><a name="2819">
</a><a name="2820" href="#2756" class="Function">dec≤</a><a name="2824"> </a><a name="2825" class="InductiveConstructor">zero</a><a name="2829">     </a><a name="2834" class="Symbol">(</a><a name="2835" class="InductiveConstructor">succ</a><a name="2839"> </a><a name="2840" href="#2840" class="Bound">n</a><a name="2841" class="Symbol">)</a><a name="2842"> </a><a name="2843" class="Symbol">=</a><a name="2844"> </a><a name="2845" class="InductiveConstructor">yes</a><a name="2848"> </a><a name="2849" href="#2563" class="InductiveConstructor">0≤n</a><a name="2852">
</a><a name="2853" href="#2756" class="Function">dec≤</a><a name="2857"> </a><a name="2858" class="Symbol">(</a><a name="2859" class="InductiveConstructor">succ</a><a name="2863"> </a><a name="2864" href="#2864" class="Bound">m</a><a name="2865" class="Symbol">)</a><a name="2866"> </a><a name="2867" class="InductiveConstructor">zero</a><a name="2871">     </a><a name="2876" class="Symbol">=</a><a name="2877"> </a><a name="2878" class="InductiveConstructor">no</a><a name="2880"> </a><a name="2881" class="Symbol">(λ</a><a name="2883"> </a><a name="2884" class="Symbol">())</a><a name="2887">
</a><a name="2888" href="#2756" class="Function">dec≤</a><a name="2892"> </a><a name="2893" class="Symbol">(</a><a name="2894" class="InductiveConstructor">succ</a><a name="2898"> </a><a name="2899" href="#2899" class="Bound">m</a><a name="2900" class="Symbol">)</a><a name="2901"> </a><a name="2902" class="Symbol">(</a><a name="2903" class="InductiveConstructor">succ</a><a name="2907"> </a><a name="2908" href="#2908" class="Bound">n</a><a name="2909" class="Symbol">)</a><a name="2910"> </a><a name="2911" class="Keyword">with</a><a name="2915"> </a><a name="2916" href="#2756" class="Function">dec≤</a><a name="2920"> </a><a name="2921" href="#2899" class="Bound">m</a><a name="2922"> </a><a name="2923" href="#2908" class="Bound">n</a><a name="2924">
</a><a name="2925" href="#2756" class="Function">dec≤</a><a name="2929"> </a><a name="2930" class="Symbol">(</a><a name="2931" class="InductiveConstructor">succ</a><a name="2935"> </a><a name="2936" href="#2936" class="Bound">m</a><a name="2937" class="Symbol">)</a><a name="2938"> </a><a name="2939" class="Symbol">(</a><a name="2940" class="InductiveConstructor">succ</a><a name="2944"> </a><a name="2945" href="#2945" class="Bound">n</a><a name="2946" class="Symbol">)</a><a name="2947"> </a><a name="2948" class="Symbol">|</a><a name="2949"> </a><a name="2950" class="InductiveConstructor">yes</a><a name="2953"> </a><a name="2954" href="#2954" class="Bound">p</a><a name="2955"> </a><a name="2956" class="Symbol">=</a><a name="2957"> </a><a name="2958" class="InductiveConstructor">yes</a><a name="2961"> </a><a name="2962" class="Symbol">(</a><a name="2963" href="#2592" class="InductiveConstructor">≤succ</a><a name="2968"> </a><a name="2969" href="#2954" class="Bound">p</a><a name="2970" class="Symbol">)</a><a name="2971">
</a><a name="2972" href="#2756" class="Function">dec≤</a><a name="2976"> </a><a name="2977" class="Symbol">(</a><a name="2978" class="InductiveConstructor">succ</a><a name="2982"> </a><a name="2983" href="#2983" class="Bound">m</a><a name="2984" class="Symbol">)</a><a name="2985"> </a><a name="2986" class="Symbol">(</a><a name="2987" class="InductiveConstructor">succ</a><a name="2991"> </a><a name="2992" href="#2992" class="Bound">n</a><a name="2993" class="Symbol">)</a><a name="2994"> </a><a name="2995" class="Symbol">|</a><a name="2996"> </a><a name="2997" class="InductiveConstructor">no</a><a name="2999">  </a><a name="3001" href="#3001" class="Bound">p</a><a name="3002"> </a><a name="3003" class="Symbol">=</a><a name="3004"> </a><a name="3005" class="InductiveConstructor">no</a><a name="3007"> </a><a name="3008" class="Symbol">(λ</a><a name="3010"> </a><a name="3011" href="#3011" class="Bound">q</a><a name="3012"> </a><a name="3013" class="Symbol">→</a><a name="3014"> </a><a name="3015" href="#3001" class="Bound">p</a><a name="3016"> </a><a name="3017" class="Symbol">(</a><a name="3018" href="#2641" class="Function">dec≤lemma</a><a name="3027"> </a><a name="3028" href="#3011" class="Bound">q</a><a name="3029" class="Symbol">))</a><a name="3031">

</a><a name="3033" href="#3033" class="Function">Atoℕ</a><a name="3037"> </a><a name="3038" class="Symbol">:</a><a name="3039"> </a><a name="3040" class="Datatype">Atom</a><a name="3044"> </a><a name="3045" class="Symbol">→</a><a name="3046"> </a><a name="3047" class="Datatype">ℕ</a><a name="3048">
</a><a name="3049" href="#3033" class="Function">Atoℕ</a><a name="3053"> </a><a name="3054" class="InductiveConstructor">root</a><a name="3058">     </a><a name="3063" class="Symbol">=</a><a name="3064"> </a><a name="3065" class="InductiveConstructor">zero</a><a name="3069">
</a><a name="3070" href="#3033" class="Function">Atoℕ</a><a name="3074"> </a><a name="3075" class="Symbol">(</a><a name="3076" class="InductiveConstructor">next</a><a name="3080"> </a><a name="3081" href="#3081" class="Bound">a</a><a name="3082" class="Symbol">)</a><a name="3083"> </a><a name="3084" class="Symbol">=</a><a name="3085"> </a><a name="3086" class="InductiveConstructor">succ</a><a name="3090"> </a><a name="3091" class="Symbol">(</a><a name="3092" href="#3033" class="Function">Atoℕ</a><a name="3096"> </a><a name="3097" href="#3081" class="Bound">a</a><a name="3098" class="Symbol">)</a><a name="3099">

</a><a name="3101" href="#3101" class="Function">AtListSucc</a><a name="3111"> </a><a name="3112" class="Symbol">:</a><a name="3113"> </a><a name="3114" class="Datatype">List</a><a name="3118"> </a><a name="3119" class="Datatype">Atom</a><a name="3123"> </a><a name="3124" class="Symbol">→</a><a name="3125"> </a><a name="3126" class="Datatype">List</a><a name="3130"> </a><a name="3131" class="Datatype">Atom</a><a name="3135">
</a><a name="3136" href="#3101" class="Function">AtListSucc</a><a name="3146"> </a><a name="3147" class="InductiveConstructor">[]</a><a name="3149"> </a><a name="3150" class="Symbol">=</a><a name="3151"> </a><a name="3152" class="Function Operator">[</a><a name="3153"> </a><a name="3154" class="InductiveConstructor">root</a><a name="3158"> </a><a name="3159" class="Function Operator">]</a><a name="3160">
</a><a name="3161" href="#3101" class="Function">AtListSucc</a><a name="3171"> </a><a name="3172" class="Symbol">(</a><a name="3173" href="#3173" class="Bound">a</a><a name="3174"> </a><a name="3175" class="InductiveConstructor Operator">::</a><a name="3177"> </a><a name="3178" href="#3178" class="Bound">as</a><a name="3180" class="Symbol">)</a><a name="3181"> </a><a name="3182" class="Symbol">=</a><a name="3183"> </a><a name="3184" class="Symbol">(</a><a name="3185" class="InductiveConstructor">next</a><a name="3189"> </a><a name="3190" href="#3173" class="Bound">a</a><a name="3191" class="Symbol">)</a><a name="3192"> </a><a name="3193" class="InductiveConstructor Operator">::</a><a name="3195"> </a><a name="3196" class="Symbol">(</a><a name="3197" href="#3173" class="Bound">a</a><a name="3198"> </a><a name="3199" class="InductiveConstructor Operator">::</a><a name="3201"> </a><a name="3202" href="#3178" class="Bound">as</a><a name="3204" class="Symbol">)</a><a name="3205">

</a><a name="3207" href="#3207" class="Function">coSuppVec</a><a name="3216"> </a><a name="3217" class="Symbol">:</a><a name="3218"> </a><a name="3219" class="Symbol">{</a><a name="3220" href="#3220" class="Bound">X</a><a name="3221"> </a><a name="3222" class="Symbol">:</a><a name="3223"> </a><a name="3224" class="PrimitiveType">Set</a><a name="3227" class="Symbol">}</a><a name="3228"> </a><a name="3229" class="Symbol">{</a><a name="3230" href="#3230" class="Bound">n</a><a name="3231"> </a><a name="3232" class="Symbol">:</a><a name="3233"> </a><a name="3234" class="Datatype">ℕ</a><a name="3235" class="Symbol">}</a><a name="3236"> </a><a name="3237" class="Symbol">→</a><a name="3238"> </a><a name="3239" class="Datatype">Vec</a><a name="3242"> </a><a name="3243" href="#3220" class="Bound">X</a><a name="3244"> </a><a name="3245" href="#3230" class="Bound">n</a><a name="3246"> </a><a name="3247" class="Symbol">→</a><a name="3248"> </a><a name="3249" class="Datatype">List</a><a name="3253"> </a><a name="3254" class="Datatype">Atom</a><a name="3258">
</a><a name="3259" href="#3207" class="Function">coSuppVec</a><a name="3268"> </a><a name="3269" class="InductiveConstructor">[]</a><a name="3271"> </a><a name="3272" class="Symbol">=</a><a name="3273"> </a><a name="3274" class="InductiveConstructor">[]</a><a name="3276">
</a><a name="3277" href="#3207" class="Function">coSuppVec</a><a name="3286"> </a><a name="3287" class="Symbol">(</a><a name="3288" href="#3288" class="Bound">x</a><a name="3289"> </a><a name="3290" class="InductiveConstructor Operator">::</a><a name="3292"> </a><a name="3293" href="#3293" class="Bound">xs</a><a name="3295" class="Symbol">)</a><a name="3296"> </a><a name="3297" class="Symbol">=</a><a name="3298"> </a><a name="3299" href="#3101" class="Function">AtListSucc</a><a name="3309"> </a><a name="3310" class="Symbol">(</a><a name="3311" href="#3207" class="Function">coSuppVec</a><a name="3320"> </a><a name="3321" href="#3293" class="Bound">xs</a><a name="3323" class="Symbol">)</a></code></pre>
<p>As we are defining multisets as a coNominal set, we need to define an action of permutations on our type. As we are looking to equate all reorderings of our multiSets, we define the action to simply be the standard permuation action on lists.</p>
<pre class="Agda"><code><a name="3580"></a><a name="3595" href="#3595" class="Function">getVal</a><a name="3601"> </a><a name="3602" class="Symbol">:</a><a name="3603"> </a><a name="3604" class="Symbol">{</a><a name="3605" href="#3605" class="Bound">X</a><a name="3606"> </a><a name="3607" class="Symbol">:</a><a name="3608"> </a><a name="3609" class="PrimitiveType">Set</a><a name="3612" class="Symbol">}</a><a name="3613"> </a><a name="3614" class="Symbol">{</a><a name="3615" href="#3615" class="Bound">n</a><a name="3616"> </a><a name="3617" class="Symbol">:</a><a name="3618"> </a><a name="3619" class="Datatype">ℕ</a><a name="3620" class="Symbol">}</a><a name="3621"> </a><a name="3622" class="Symbol">→</a><a name="3623"> </a><a name="3624" class="Symbol">(</a><a name="3625" href="#3625" class="Bound">i</a><a name="3626"> </a><a name="3627" class="Symbol">:</a><a name="3628"> </a><a name="3629" class="Datatype">ℕ</a><a name="3630" class="Symbol">)</a><a name="3631"> </a><a name="3632" class="Symbol">→</a><a name="3633"> </a><a name="3634" class="Datatype">Vec</a><a name="3637"> </a><a name="3638" href="#3605" class="Bound">X</a><a name="3639"> </a><a name="3640" href="#3615" class="Bound">n</a><a name="3641"> </a><a name="3642" class="Symbol">→</a><a name="3643"> </a><a name="3644" class="Symbol">(</a><a name="3645" class="InductiveConstructor">succ</a><a name="3649"> </a><a name="3650" href="#3625" class="Bound">i</a><a name="3651" class="Symbol">)</a><a name="3652"> </a><a name="3653" href="#2537" class="Datatype Operator">≤</a><a name="3654"> </a><a name="3655" href="#3615" class="Bound">n</a><a name="3656"> </a><a name="3657" class="Symbol">→</a><a name="3658"> </a><a name="3659" href="#3605" class="Bound">X</a><a name="3660">
</a><a name="3661" href="#3595" class="Function">getVal</a><a name="3667"> </a><a name="3668" class="Symbol">{</a><a name="3669" class="Argument">n</a><a name="3670"> </a><a name="3671" class="Symbol">=</a><a name="3672"> </a><a name="3673" class="InductiveConstructor">succ</a><a name="3677"> </a><a name="3678" href="#3678" class="Bound">n</a><a name="3679" class="Symbol">}</a><a name="3680"> </a><a name="3681" class="InductiveConstructor">zero</a><a name="3685"> </a><a name="3686" class="Symbol">(</a><a name="3687" href="#3687" class="Bound">a</a><a name="3688"> </a><a name="3689" class="InductiveConstructor Operator">::</a><a name="3691"> </a><a name="3692" href="#3692" class="Bound">v</a><a name="3693" class="Symbol">)</a><a name="3694"> </a><a name="3695" class="Symbol">(</a><a name="3696" href="#2592" class="InductiveConstructor">≤succ</a><a name="3701"> </a><a name="3702" href="#3702" class="Bound">p</a><a name="3703" class="Symbol">)</a><a name="3704"> </a><a name="3705" class="Symbol">=</a><a name="3706"> </a><a name="3707" href="#3687" class="Bound">a</a><a name="3708">
</a><a name="3709" href="#3595" class="Function">getVal</a><a name="3715"> </a><a name="3716" class="Symbol">{</a><a name="3717" class="Argument">n</a><a name="3718"> </a><a name="3719" class="Symbol">=</a><a name="3720"> </a><a name="3721" class="InductiveConstructor">succ</a><a name="3725"> </a><a name="3726" href="#3726" class="Bound">n</a><a name="3727" class="Symbol">}</a><a name="3728"> </a><a name="3729" class="Symbol">(</a><a name="3730" class="InductiveConstructor">succ</a><a name="3734"> </a><a name="3735" href="#3735" class="Bound">i</a><a name="3736" class="Symbol">)</a><a name="3737"> </a><a name="3738" class="Symbol">(</a><a name="3739" href="#3739" class="Bound">a</a><a name="3740"> </a><a name="3741" class="InductiveConstructor Operator">::</a><a name="3743"> </a><a name="3744" href="#3744" class="Bound">v</a><a name="3745" class="Symbol">)</a><a name="3746"> </a><a name="3747" class="Symbol">(</a><a name="3748" href="#2592" class="InductiveConstructor">≤succ</a><a name="3753"> </a><a name="3754" href="#3754" class="Bound">p</a><a name="3755" class="Symbol">)</a><a name="3756"> </a><a name="3757" class="Symbol">=</a><a name="3758"> </a><a name="3759" href="#3595" class="Function">getVal</a><a name="3765"> </a><a name="3766" href="#3735" class="Bound">i</a><a name="3767"> </a><a name="3768" href="#3744" class="Bound">v</a><a name="3769"> </a><a name="3770" href="#3754" class="Bound">p</a><a name="3771">

</a><a name="3773" href="#3773" class="Function">replace</a><a name="3780"> </a><a name="3781" class="Symbol">:</a><a name="3782"> </a><a name="3783" class="Symbol">{</a><a name="3784" href="#3784" class="Bound">X</a><a name="3785"> </a><a name="3786" class="Symbol">:</a><a name="3787"> </a><a name="3788" class="PrimitiveType">Set</a><a name="3791" class="Symbol">}</a><a name="3792"> </a><a name="3793" class="Symbol">{</a><a name="3794" href="#3794" class="Bound">n</a><a name="3795"> </a><a name="3796" class="Symbol">:</a><a name="3797"> </a><a name="3798" class="Datatype">ℕ</a><a name="3799" class="Symbol">}</a><a name="3800"> </a><a name="3801" class="Symbol">→</a><a name="3802"> </a><a name="3803" class="Symbol">(</a><a name="3804" href="#3804" class="Bound">i</a><a name="3805"> </a><a name="3806" class="Symbol">:</a><a name="3807"> </a><a name="3808" class="Datatype">ℕ</a><a name="3809" class="Symbol">)</a><a name="3810"> </a><a name="3811" class="Symbol">→</a><a name="3812"> </a><a name="3813" href="#3784" class="Bound">X</a><a name="3814"> </a><a name="3815" class="Symbol">→</a><a name="3816"> </a><a name="3817" class="Datatype">Vec</a><a name="3820"> </a><a name="3821" href="#3784" class="Bound">X</a><a name="3822"> </a><a name="3823" href="#3794" class="Bound">n</a><a name="3824"> </a><a name="3825" class="Symbol">→</a><a name="3826"> </a><a name="3827" class="Symbol">(</a><a name="3828" class="InductiveConstructor">succ</a><a name="3832"> </a><a name="3833" href="#3804" class="Bound">i</a><a name="3834" class="Symbol">)</a><a name="3835"> </a><a name="3836" href="#2537" class="Datatype Operator">≤</a><a name="3837"> </a><a name="3838" href="#3794" class="Bound">n</a><a name="3839"> </a><a name="3840" class="Symbol">→</a><a name="3841"> </a><a name="3842" class="Datatype">Vec</a><a name="3845"> </a><a name="3846" href="#3784" class="Bound">X</a><a name="3847"> </a><a name="3848" href="#3794" class="Bound">n</a><a name="3849">
</a><a name="3850" href="#3773" class="Function">replace</a><a name="3857"> </a><a name="3858" class="Symbol">{</a><a name="3859" class="Argument">n</a><a name="3860"> </a><a name="3861" class="Symbol">=</a><a name="3862"> </a><a name="3863" class="InductiveConstructor">succ</a><a name="3867"> </a><a name="3868" href="#3868" class="Bound">n</a><a name="3869" class="Symbol">}</a><a name="3870"> </a><a name="3871" class="InductiveConstructor">zero</a><a name="3875"> </a><a name="3876" href="#3876" class="Bound">x</a><a name="3877"> </a><a name="3878" class="Symbol">(</a><a name="3879" href="#3879" class="Bound">a</a><a name="3880"> </a><a name="3881" class="InductiveConstructor Operator">::</a><a name="3883"> </a><a name="3884" href="#3884" class="Bound">v</a><a name="3885" class="Symbol">)</a><a name="3886"> </a><a name="3887" class="Symbol">(</a><a name="3888" href="#2592" class="InductiveConstructor">≤succ</a><a name="3893"> </a><a name="3894" href="#3894" class="Bound">p</a><a name="3895" class="Symbol">)</a><a name="3896"> </a><a name="3897" class="Symbol">=</a><a name="3898"> </a><a name="3899" href="#3876" class="Bound">x</a><a name="3900"> </a><a name="3901" class="InductiveConstructor Operator">::</a><a name="3903"> </a><a name="3904" href="#3884" class="Bound">v</a><a name="3905">
</a><a name="3906" href="#3773" class="Function">replace</a><a name="3913"> </a><a name="3914" class="Symbol">{</a><a name="3915" class="Argument">n</a><a name="3916"> </a><a name="3917" class="Symbol">=</a><a name="3918"> </a><a name="3919" class="InductiveConstructor">succ</a><a name="3923"> </a><a name="3924" href="#3924" class="Bound">n</a><a name="3925" class="Symbol">}</a><a name="3926"> </a><a name="3927" class="Symbol">(</a><a name="3928" class="InductiveConstructor">succ</a><a name="3932"> </a><a name="3933" href="#3933" class="Bound">i</a><a name="3934" class="Symbol">)</a><a name="3935"> </a><a name="3936" href="#3936" class="Bound">x</a><a name="3937"> </a><a name="3938" class="Symbol">(</a><a name="3939" href="#3939" class="Bound">a</a><a name="3940"> </a><a name="3941" class="InductiveConstructor Operator">::</a><a name="3943"> </a><a name="3944" href="#3944" class="Bound">v</a><a name="3945" class="Symbol">)</a><a name="3946"> </a><a name="3947" class="Symbol">(</a><a name="3948" href="#2592" class="InductiveConstructor">≤succ</a><a name="3953"> </a><a name="3954" href="#3954" class="Bound">p</a><a name="3955" class="Symbol">)</a><a name="3956"> </a><a name="3957" class="Symbol">=</a><a name="3958"> </a><a name="3959" href="#3939" class="Bound">a</a><a name="3960"> </a><a name="3961" class="InductiveConstructor Operator">::</a><a name="3963"> </a><a name="3964" class="Symbol">(</a><a name="3965" href="#3773" class="Function">replace</a><a name="3972"> </a><a name="3973" href="#3933" class="Bound">i</a><a name="3974"> </a><a name="3975" href="#3936" class="Bound">x</a><a name="3976"> </a><a name="3977" href="#3944" class="Bound">v</a><a name="3978"> </a><a name="3979" href="#3954" class="Bound">p</a><a name="3980" class="Symbol">)</a><a name="3981">

</a><a name="3983" href="#3983" class="Function">headSwap</a><a name="3991"> </a><a name="3992" class="Symbol">:</a><a name="3993"> </a><a name="3994" class="Symbol">{</a><a name="3995" href="#3995" class="Bound">X</a><a name="3996"> </a><a name="3997" class="Symbol">:</a><a name="3998"> </a><a name="3999" class="PrimitiveType">Set</a><a name="4002" class="Symbol">}</a><a name="4003"> </a><a name="4004" class="Symbol">{</a><a name="4005" href="#4005" class="Bound">n</a><a name="4006"> </a><a name="4007" class="Symbol">:</a><a name="4008"> </a><a name="4009" class="Datatype">ℕ</a><a name="4010" class="Symbol">}</a><a name="4011"> </a><a name="4012" class="Symbol">→</a><a name="4013"> </a><a name="4014" class="Symbol">(</a><a name="4015" href="#4015" class="Bound">i</a><a name="4016"> </a><a name="4017" class="Symbol">:</a><a name="4018"> </a><a name="4019" class="Datatype">ℕ</a><a name="4020" class="Symbol">)</a><a name="4021"> </a><a name="4022" class="Symbol">→</a><a name="4023"> </a><a name="4024" class="Datatype">Vec</a><a name="4027"> </a><a name="4028" href="#3995" class="Bound">X</a><a name="4029"> </a><a name="4030" href="#4005" class="Bound">n</a><a name="4031"> </a><a name="4032" class="Symbol">→</a><a name="4033"> </a><a name="4034" class="Symbol">(</a><a name="4035" class="InductiveConstructor">succ</a><a name="4039"> </a><a name="4040" href="#4015" class="Bound">i</a><a name="4041" class="Symbol">)</a><a name="4042"> </a><a name="4043" href="#2537" class="Datatype Operator">≤</a><a name="4044"> </a><a name="4045" href="#4005" class="Bound">n</a><a name="4046"> </a><a name="4047" class="Symbol">→</a><a name="4048"> </a><a name="4049" class="Datatype">Vec</a><a name="4052"> </a><a name="4053" href="#3995" class="Bound">X</a><a name="4054"> </a><a name="4055" href="#4005" class="Bound">n</a><a name="4056">
</a><a name="4057" href="#3983" class="Function">headSwap</a><a name="4065"> </a><a name="4066" class="InductiveConstructor">zero</a><a name="4070"> </a><a name="4071" class="Symbol">(</a><a name="4072" href="#4072" class="Bound">a</a><a name="4073"> </a><a name="4074" class="InductiveConstructor Operator">::</a><a name="4076"> </a><a name="4077" href="#4077" class="Bound">v</a><a name="4078" class="Symbol">)</a><a name="4079"> </a><a name="4080" class="Symbol">(</a><a name="4081" href="#2592" class="InductiveConstructor">≤succ</a><a name="4086"> </a><a name="4087" href="#4087" class="Bound">p</a><a name="4088" class="Symbol">)</a><a name="4089"> </a><a name="4090" class="Symbol">=</a><a name="4091"> </a><a name="4092" href="#4072" class="Bound">a</a><a name="4093"> </a><a name="4094" class="InductiveConstructor Operator">::</a><a name="4096"> </a><a name="4097" href="#4077" class="Bound">v</a><a name="4098">
</a><a name="4099" href="#3983" class="Function">headSwap</a><a name="4107"> </a><a name="4108" class="Symbol">(</a><a name="4109" class="InductiveConstructor">succ</a><a name="4113"> </a><a name="4114" href="#4114" class="Bound">i</a><a name="4115" class="Symbol">)</a><a name="4116"> </a><a name="4117" class="Symbol">(</a><a name="4118" href="#4118" class="Bound">a</a><a name="4119"> </a><a name="4120" class="InductiveConstructor Operator">::</a><a name="4122"> </a><a name="4123" href="#4123" class="Bound">v</a><a name="4124" class="Symbol">)</a><a name="4125"> </a><a name="4126" class="Symbol">(</a><a name="4127" href="#2592" class="InductiveConstructor">≤succ</a><a name="4132"> </a><a name="4133" href="#4133" class="Bound">p</a><a name="4134" class="Symbol">)</a><a name="4135"> </a><a name="4136" class="Symbol">=</a><a name="4137"> </a><a name="4138" class="Symbol">(</a><a name="4139" href="#3595" class="Function">getVal</a><a name="4145"> </a><a name="4146" href="#4114" class="Bound">i</a><a name="4147"> </a><a name="4148" href="#4123" class="Bound">v</a><a name="4149"> </a><a name="4150" href="#4133" class="Bound">p</a><a name="4151" class="Symbol">)</a><a name="4152"> </a><a name="4153" class="InductiveConstructor Operator">::</a><a name="4155"> </a><a name="4156" class="Symbol">(</a><a name="4157" href="#3773" class="Function">replace</a><a name="4164"> </a><a name="4165" href="#4114" class="Bound">i</a><a name="4166"> </a><a name="4167" href="#4118" class="Bound">a</a><a name="4168"> </a><a name="4169" href="#4123" class="Bound">v</a><a name="4170"> </a><a name="4171" href="#4133" class="Bound">p</a><a name="4172" class="Symbol">)</a><a name="4173">

</a><a name="4175" href="#4175" class="Function">swapVec</a><a name="4182"> </a><a name="4183" class="Symbol">:</a><a name="4184"> </a><a name="4185" class="Symbol">{</a><a name="4186" href="#4186" class="Bound">X</a><a name="4187"> </a><a name="4188" class="Symbol">:</a><a name="4189"> </a><a name="4190" class="PrimitiveType">Set</a><a name="4193" class="Symbol">}</a><a name="4194"> </a><a name="4195" class="Symbol">{</a><a name="4196" href="#4196" class="Bound">n</a><a name="4197"> </a><a name="4198" class="Symbol">:</a><a name="4199"> </a><a name="4200" class="Datatype">ℕ</a><a name="4201" class="Symbol">}</a><a name="4202"> </a><a name="4203" class="Symbol">→</a><a name="4204"> </a><a name="4205" class="Datatype">Atom</a><a name="4209"> </a><a name="4210" class="Symbol">→</a><a name="4211"> </a><a name="4212" class="Datatype">Atom</a><a name="4216"> </a><a name="4217" class="Symbol">→</a><a name="4218"> </a><a name="4219" class="Datatype">Vec</a><a name="4222"> </a><a name="4223" href="#4186" class="Bound">X</a><a name="4224"> </a><a name="4225" href="#4196" class="Bound">n</a><a name="4226"> </a><a name="4227" class="Symbol">→</a><a name="4228"> </a><a name="4229" class="Datatype">Vec</a><a name="4232"> </a><a name="4233" href="#4186" class="Bound">X</a><a name="4234"> </a><a name="4235" href="#4196" class="Bound">n</a><a name="4236">
</a><a name="4237" href="#4175" class="Function">swapVec</a><a name="4244"> </a><a name="4245" class="Symbol">{</a><a name="4246" href="#4246" class="Bound">X</a><a name="4247" class="Symbol">}</a><a name="4248"> </a><a name="4249" class="Symbol">{</a><a name="4250" href="#4250" class="Bound">n</a><a name="4251" class="Symbol">}</a><a name="4252"> </a><a name="4253" href="#4253" class="Bound">a</a><a name="4254"> </a><a name="4255" href="#4255" class="Bound">b</a><a name="4256"> </a><a name="4257" href="#4257" class="Bound">v</a><a name="4258"> </a><a name="4259" class="Keyword">with</a><a name="4263"> </a><a name="4264" href="#2756" class="Function">dec≤</a><a name="4268"> </a><a name="4269" class="Symbol">(</a><a name="4270" class="InductiveConstructor">succ</a><a name="4274"> </a><a name="4275" class="Symbol">(</a><a name="4276" href="#3033" class="Function">Atoℕ</a><a name="4280"> </a><a name="4281" href="#4253" class="Bound">a</a><a name="4282" class="Symbol">))</a><a name="4284"> </a><a name="4285" href="#4250" class="Bound">n</a><a name="4286"> </a><a name="4287" class="Symbol">|</a><a name="4288"> </a><a name="4289" href="#2756" class="Function">dec≤</a><a name="4293"> </a><a name="4294" class="Symbol">(</a><a name="4295" class="InductiveConstructor">succ</a><a name="4299"> </a><a name="4300" class="Symbol">(</a><a name="4301" href="#3033" class="Function">Atoℕ</a><a name="4305"> </a><a name="4306" href="#4255" class="Bound">b</a><a name="4307" class="Symbol">))</a><a name="4309"> </a><a name="4310" href="#4250" class="Bound">n</a><a name="4311">
</a><a name="4312" href="#4175" class="Function">swapVec</a><a name="4319"> </a><a name="4320" class="InductiveConstructor">root</a><a name="4324">     </a><a name="4329" class="InductiveConstructor">root</a><a name="4333">     </a><a name="4338" href="#4338" class="Bound">v</a><a name="4339">         </a><a name="4348" class="Symbol">|</a><a name="4349"> </a><a name="4350" class="InductiveConstructor">yes</a><a name="4353"> </a><a name="4354" href="#4354" class="Bound">p</a><a name="4355">         </a><a name="4364" class="Symbol">|</a><a name="4365"> </a><a name="4366" class="InductiveConstructor">yes</a><a name="4369"> </a><a name="4370" href="#4370" class="Bound">q</a><a name="4371">
                                    </a><a name="4408" class="Symbol">=</a><a name="4409"> </a><a name="4410" href="#4338" class="Bound">v</a><a name="4411">
</a><a name="4412" href="#4175" class="Function">swapVec</a><a name="4419"> </a><a name="4420" class="InductiveConstructor">root</a><a name="4424">     </a><a name="4429" class="Symbol">(</a><a name="4430" class="InductiveConstructor">next</a><a name="4434"> </a><a name="4435" href="#4435" class="Bound">b</a><a name="4436" class="Symbol">)</a><a name="4437"> </a><a name="4438" class="Symbol">(</a><a name="4439" href="#4439" class="Bound">x</a><a name="4440"> </a><a name="4441" class="InductiveConstructor Operator">::</a><a name="4443"> </a><a name="4444" href="#4444" class="Bound">v'</a><a name="4446" class="Symbol">)</a><a name="4447"> </a><a name="4448" class="Symbol">|</a><a name="4449"> </a><a name="4450" class="InductiveConstructor">yes</a><a name="4453"> </a><a name="4454" href="#4454" class="Bound">p</a><a name="4455">         </a><a name="4464" class="Symbol">|</a><a name="4465"> </a><a name="4466" class="InductiveConstructor">yes</a><a name="4469"> </a><a name="4470" class="Symbol">(</a><a name="4471" href="#2592" class="InductiveConstructor">≤succ</a><a name="4476"> </a><a name="4477" href="#4477" class="Bound">q</a><a name="4478" class="Symbol">)</a><a name="4479">
                                    </a><a name="4516" class="Symbol">=</a><a name="4517"> </a><a name="4518" href="#3983" class="Function">headSwap</a><a name="4526"> </a><a name="4527" class="Symbol">(</a><a name="4528" href="#3033" class="Function">Atoℕ</a><a name="4532"> </a><a name="4533" class="Symbol">(</a><a name="4534" class="InductiveConstructor">next</a><a name="4538"> </a><a name="4539" href="#4435" class="Bound">b</a><a name="4540" class="Symbol">))</a><a name="4542"> </a><a name="4543" class="Symbol">(</a><a name="4544" href="#4439" class="Bound">x</a><a name="4545"> </a><a name="4546" class="InductiveConstructor Operator">::</a><a name="4548"> </a><a name="4549" href="#4444" class="Bound">v'</a><a name="4551" class="Symbol">)</a><a name="4552"> </a><a name="4553" class="Symbol">(</a><a name="4554" href="#2592" class="InductiveConstructor">≤succ</a><a name="4559"> </a><a name="4560" href="#4477" class="Bound">q</a><a name="4561" class="Symbol">)</a><a name="4562">
</a><a name="4563" href="#4175" class="Function">swapVec</a><a name="4570"> </a><a name="4571" class="Symbol">(</a><a name="4572" class="InductiveConstructor">next</a><a name="4576"> </a><a name="4577" href="#4577" class="Bound">a</a><a name="4578" class="Symbol">)</a><a name="4579"> </a><a name="4580" class="InductiveConstructor">root</a><a name="4584">     </a><a name="4589" class="Symbol">(</a><a name="4590" href="#4590" class="Bound">x</a><a name="4591"> </a><a name="4592" class="InductiveConstructor Operator">::</a><a name="4594"> </a><a name="4595" href="#4595" class="Bound">v'</a><a name="4597" class="Symbol">)</a><a name="4598"> </a><a name="4599" class="Symbol">|</a><a name="4600"> </a><a name="4601" class="InductiveConstructor">yes</a><a name="4604"> </a><a name="4605" class="Symbol">(</a><a name="4606" href="#2592" class="InductiveConstructor">≤succ</a><a name="4611"> </a><a name="4612" href="#4612" class="Bound">p</a><a name="4613" class="Symbol">)</a><a name="4614"> </a><a name="4615" class="Symbol">|</a><a name="4616"> </a><a name="4617" class="InductiveConstructor">yes</a><a name="4620"> </a><a name="4621" href="#4621" class="Bound">q</a><a name="4622">
                                    </a><a name="4659" class="Symbol">=</a><a name="4660"> </a><a name="4661" href="#3983" class="Function">headSwap</a><a name="4669"> </a><a name="4670" class="Symbol">(</a><a name="4671" href="#3033" class="Function">Atoℕ</a><a name="4675"> </a><a name="4676" class="Symbol">(</a><a name="4677" class="InductiveConstructor">next</a><a name="4681"> </a><a name="4682" href="#4577" class="Bound">a</a><a name="4683" class="Symbol">))</a><a name="4685"> </a><a name="4686" class="Symbol">(</a><a name="4687" href="#4590" class="Bound">x</a><a name="4688"> </a><a name="4689" class="InductiveConstructor Operator">::</a><a name="4691"> </a><a name="4692" href="#4595" class="Bound">v'</a><a name="4694" class="Symbol">)</a><a name="4695"> </a><a name="4696" class="Symbol">(</a><a name="4697" href="#2592" class="InductiveConstructor">≤succ</a><a name="4702"> </a><a name="4703" href="#4612" class="Bound">p</a><a name="4704" class="Symbol">)</a><a name="4705">
</a><a name="4706" href="#4175" class="Function">swapVec</a><a name="4713"> </a><a name="4714" class="Symbol">(</a><a name="4715" class="InductiveConstructor">next</a><a name="4719"> </a><a name="4720" href="#4720" class="Bound">a</a><a name="4721" class="Symbol">)</a><a name="4722"> </a><a name="4723" class="Symbol">(</a><a name="4724" class="InductiveConstructor">next</a><a name="4728"> </a><a name="4729" href="#4729" class="Bound">b</a><a name="4730" class="Symbol">)</a><a name="4731"> </a><a name="4732" class="Symbol">(</a><a name="4733" href="#4733" class="Bound">x</a><a name="4734"> </a><a name="4735" class="InductiveConstructor Operator">::</a><a name="4737"> </a><a name="4738" href="#4738" class="Bound">v'</a><a name="4740" class="Symbol">)</a><a name="4741"> </a><a name="4742" class="Symbol">|</a><a name="4743"> </a><a name="4744" class="InductiveConstructor">yes</a><a name="4747"> </a><a name="4748" href="#4748" class="Bound">p</a><a name="4749">         </a><a name="4758" class="Symbol">|</a><a name="4759"> </a><a name="4760" class="InductiveConstructor">yes</a><a name="4763"> </a><a name="4764" href="#4764" class="Bound">q</a><a name="4765">
                                    </a><a name="4802" class="Symbol">=</a><a name="4803"> </a><a name="4804" href="#4733" class="Bound">x</a><a name="4805"> </a><a name="4806" class="InductiveConstructor Operator">::</a><a name="4808"> </a><a name="4809" class="Symbol">(</a><a name="4810" href="#4175" class="Function">swapVec</a><a name="4817"> </a><a name="4818" href="#4720" class="Bound">a</a><a name="4819"> </a><a name="4820" href="#4729" class="Bound">b</a><a name="4821"> </a><a name="4822" href="#4738" class="Bound">v'</a><a name="4824" class="Symbol">)</a><a name="4825">
</a><a name="4826" href="#4175" class="Function">swapVec</a><a name="4833"> </a><a name="4834" class="Symbol">{</a><a name="4835" href="#4835" class="Bound">X</a><a name="4836" class="Symbol">}</a><a name="4837"> </a><a name="4838" class="Symbol">{</a><a name="4839" href="#4839" class="Bound">n</a><a name="4840" class="Symbol">}</a><a name="4841"> </a><a name="4842" href="#4842" class="Bound">a</a><a name="4843"> </a><a name="4844" href="#4844" class="Bound">b</a><a name="4845"> </a><a name="4846" href="#4846" class="Bound">v</a><a name="4847"> </a><a name="4848" class="Symbol">|</a><a name="4849"> </a><a name="4850" class="Symbol">_</a><a name="4851">    </a><a name="4855" class="Symbol">|</a><a name="4856"> </a><a name="4857" class="Symbol">_</a><a name="4858">    </a><a name="4862" class="Symbol">=</a><a name="4863"> </a><a name="4864" href="#4846" class="Bound">v</a><a name="4865">

</a><a name="4867" href="#4867" class="Function">permActVec</a><a name="4877"> </a><a name="4878" class="Symbol">:</a><a name="4879"> </a><a name="4880" class="Symbol">{</a><a name="4881" href="#4881" class="Bound">X</a><a name="4882"> </a><a name="4883" class="Symbol">:</a><a name="4884"> </a><a name="4885" class="PrimitiveType">Set</a><a name="4888" class="Symbol">}</a><a name="4889"> </a><a name="4890" class="Symbol">{</a><a name="4891" href="#4891" class="Bound">n</a><a name="4892"> </a><a name="4893" class="Symbol">:</a><a name="4894"> </a><a name="4895" class="Datatype">ℕ</a><a name="4896" class="Symbol">}</a><a name="4897"> </a><a name="4898" class="Symbol">→</a><a name="4899"> </a><a name="4900" class="Function">Perm</a><a name="4904"> </a><a name="4905" class="Symbol">→</a><a name="4906"> </a><a name="4907" class="Datatype">Vec</a><a name="4910"> </a><a name="4911" href="#4881" class="Bound">X</a><a name="4912"> </a><a name="4913" href="#4891" class="Bound">n</a><a name="4914"> </a><a name="4915" class="Symbol">→</a><a name="4916"> </a><a name="4917" class="Datatype">Vec</a><a name="4920"> </a><a name="4921" href="#4881" class="Bound">X</a><a name="4922"> </a><a name="4923" href="#4891" class="Bound">n</a><a name="4924">
</a><a name="4925" href="#4867" class="Function">permActVec</a><a name="4935"> </a><a name="4936" class="InductiveConstructor">[]</a><a name="4938"> </a><a name="4939" href="#4939" class="Bound">v</a><a name="4940"> </a><a name="4941" class="Symbol">=</a><a name="4942"> </a><a name="4943" href="#4939" class="Bound">v</a><a name="4944">
</a><a name="4945" href="#4867" class="Function">permActVec</a><a name="4955"> </a><a name="4956" class="Symbol">((</a><a name="4958" href="#4958" class="Bound">a</a><a name="4959"> </a><a name="4960" class="InductiveConstructor Operator">,</a><a name="4961"> </a><a name="4962" href="#4962" class="Bound">b</a><a name="4963" class="Symbol">)</a><a name="4964"> </a><a name="4965" class="InductiveConstructor Operator">::</a><a name="4967"> </a><a name="4968" href="#4968" class="Bound">as</a><a name="4970" class="Symbol">)</a><a name="4971"> </a><a name="4972" href="#4972" class="Bound">v</a><a name="4973"> </a><a name="4974" class="Symbol">=</a><a name="4975"> </a><a name="4976" href="#4867" class="Function">permActVec</a><a name="4986"> </a><a name="4987" href="#4968" class="Bound">as</a><a name="4989"> </a><a name="4990" class="Symbol">(</a><a name="4991" href="#4175" class="Function">swapVec</a><a name="4998"> </a><a name="4999" href="#4958" class="Bound">a</a><a name="5000"> </a><a name="5001" href="#4962" class="Bound">b</a><a name="5002"> </a><a name="5003" href="#4972" class="Bound">v</a><a name="5004" class="Symbol">)</a></code></pre>
<p>As we want to equate all permutations, we define the equivalence relation for our coNominal set to simply be the reflexive-symmetric-transitive closure of the relation equating swaps. <code>reflEq</code> and <code>symmEq</code> could both be derived from <code>swapEq</code> and <code>transEq</code>, but out of laziness of proving reflexivity and symmetry I decided to just included the properties definitionally.</p>
<pre class="Agda"><code><a name="5389"></a><a name="5404" class="Keyword">data</a><a name="5408"> </a><a name="5409" href="#5409" class="Datatype">multiSetEq</a><a name="5419">  </a><a name="5421" class="Symbol">{</a><a name="5422" href="#5422" class="Bound">X</a><a name="5423"> </a><a name="5424" class="Symbol">:</a><a name="5425"> </a><a name="5426" class="PrimitiveType">Set</a><a name="5429" class="Symbol">}</a><a name="5430"> </a><a name="5431" class="Symbol">:</a><a name="5432"> </a><a name="5433" class="Symbol">{</a><a name="5434" href="#5434" class="Bound">n</a><a name="5435"> </a><a name="5436" class="Symbol">:</a><a name="5437"> </a><a name="5438" class="Datatype">ℕ</a><a name="5439" class="Symbol">}</a><a name="5440"> </a><a name="5441" class="Symbol">→</a><a name="5442"> </a><a name="5443" class="Function">Rel</a><a name="5446"> </a><a name="5447" class="Symbol">(</a><a name="5448" class="Datatype">Vec</a><a name="5451"> </a><a name="5452" href="#5422" class="Bound">X</a><a name="5453"> </a><a name="5454" href="#5434" class="Bound">n</a><a name="5455" class="Symbol">)</a><a name="5456"> </a><a name="5457" class="Keyword">where</a><a name="5462">
  </a><a name="5465" href="#5465" class="InductiveConstructor">swapEq</a><a name="5471"> </a><a name="5472" class="Symbol">:</a><a name="5473"> </a><a name="5474" class="Symbol">{</a><a name="5475" href="#5475" class="Bound">n</a><a name="5476"> </a><a name="5477" class="Symbol">:</a><a name="5478"> </a><a name="5479" class="Datatype">ℕ</a><a name="5480" class="Symbol">}</a><a name="5481"> </a><a name="5482" class="Symbol">{</a><a name="5483" href="#5483" class="Bound">v</a><a name="5484"> </a><a name="5485" class="Symbol">:</a><a name="5486"> </a><a name="5487" class="Datatype">Vec</a><a name="5490"> </a><a name="5491" href="#5422" class="Bound">X</a><a name="5492"> </a><a name="5493" href="#5475" class="Bound">n</a><a name="5494" class="Symbol">}</a><a name="5495"> </a><a name="5496" class="Symbol">→</a><a name="5497"> </a><a name="5498" class="Symbol">(</a><a name="5499" href="#5499" class="Bound">a</a><a name="5500"> </a><a name="5501" href="#5501" class="Bound">b</a><a name="5502"> </a><a name="5503" class="Symbol">:</a><a name="5504"> </a><a name="5505" class="Datatype">Atom</a><a name="5509" class="Symbol">)</a><a name="5510">
           </a><a name="5522" class="Symbol">→</a><a name="5523"> </a><a name="5524" href="#5409" class="Datatype">multiSetEq</a><a name="5534"> </a><a name="5535" class="Symbol">(</a><a name="5536" href="#4175" class="Function">swapVec</a><a name="5543"> </a><a name="5544" href="#5499" class="Bound">a</a><a name="5545"> </a><a name="5546" href="#5501" class="Bound">b</a><a name="5547"> </a><a name="5548" href="#5483" class="Bound">v</a><a name="5549" class="Symbol">)</a><a name="5550"> </a><a name="5551" href="#5483" class="Bound">v</a><a name="5552">
  </a><a name="5555" href="#5555" class="InductiveConstructor">reflEq</a><a name="5561"> </a><a name="5562" class="Symbol">:</a><a name="5563"> </a><a name="5564" class="Symbol">{</a><a name="5565" href="#5565" class="Bound">n</a><a name="5566"> </a><a name="5567" class="Symbol">:</a><a name="5568"> </a><a name="5569" class="Datatype">ℕ</a><a name="5570" class="Symbol">}</a><a name="5571"> </a><a name="5572" class="Symbol">{</a><a name="5573" href="#5573" class="Bound">v</a><a name="5574"> </a><a name="5575" class="Symbol">:</a><a name="5576"> </a><a name="5577" class="Datatype">Vec</a><a name="5580"> </a><a name="5581" href="#5422" class="Bound">X</a><a name="5582"> </a><a name="5583" href="#5565" class="Bound">n</a><a name="5584" class="Symbol">}</a><a name="5585"> </a><a name="5586" class="Symbol">→</a><a name="5587"> </a><a name="5588" href="#5409" class="Datatype">multiSetEq</a><a name="5598"> </a><a name="5599" href="#5573" class="Bound">v</a><a name="5600"> </a><a name="5601" href="#5573" class="Bound">v</a><a name="5602">
  </a><a name="5605" href="#5605" class="InductiveConstructor">symmEq</a><a name="5611"> </a><a name="5612" class="Symbol">:</a><a name="5613"> </a><a name="5614" class="Symbol">{</a><a name="5615" href="#5615" class="Bound">n</a><a name="5616"> </a><a name="5617" class="Symbol">:</a><a name="5618"> </a><a name="5619" class="Datatype">ℕ</a><a name="5620" class="Symbol">}</a><a name="5621"> </a><a name="5622" class="Symbol">{</a><a name="5623" href="#5623" class="Bound">v1</a><a name="5625"> </a><a name="5626" href="#5626" class="Bound">v2</a><a name="5628"> </a><a name="5629" class="Symbol">:</a><a name="5630"> </a><a name="5631" class="Datatype">Vec</a><a name="5634"> </a><a name="5635" href="#5422" class="Bound">X</a><a name="5636"> </a><a name="5637" href="#5615" class="Bound">n</a><a name="5638" class="Symbol">}</a><a name="5639"> </a><a name="5640" class="Symbol">→</a><a name="5641"> </a><a name="5642" href="#5409" class="Datatype">multiSetEq</a><a name="5652"> </a><a name="5653" href="#5623" class="Bound">v1</a><a name="5655"> </a><a name="5656" href="#5626" class="Bound">v2</a><a name="5658">
            </a><a name="5671" class="Symbol">→</a><a name="5672"> </a><a name="5673" href="#5409" class="Datatype">multiSetEq</a><a name="5683"> </a><a name="5684" href="#5626" class="Bound">v2</a><a name="5686"> </a><a name="5687" href="#5623" class="Bound">v1</a><a name="5689">
  </a><a name="5692" href="#5692" class="InductiveConstructor">transEq</a><a name="5699"> </a><a name="5700" class="Symbol">:</a><a name="5701"> </a><a name="5702" class="Symbol">{</a><a name="5703" href="#5703" class="Bound">n</a><a name="5704"> </a><a name="5705" class="Symbol">:</a><a name="5706"> </a><a name="5707" class="Datatype">ℕ</a><a name="5708" class="Symbol">}</a><a name="5709"> </a><a name="5710" class="Symbol">{</a><a name="5711" href="#5711" class="Bound">v1</a><a name="5713"> </a><a name="5714" href="#5714" class="Bound">v2</a><a name="5716"> </a><a name="5717" href="#5717" class="Bound">v3</a><a name="5719"> </a><a name="5720" class="Symbol">:</a><a name="5721"> </a><a name="5722" class="Datatype">Vec</a><a name="5725"> </a><a name="5726" href="#5422" class="Bound">X</a><a name="5727"> </a><a name="5728" href="#5703" class="Bound">n</a><a name="5729" class="Symbol">}</a><a name="5730"> </a><a name="5731" class="Symbol">→</a><a name="5732"> </a><a name="5733" href="#5409" class="Datatype">multiSetEq</a><a name="5743"> </a><a name="5744" href="#5711" class="Bound">v1</a><a name="5746"> </a><a name="5747" href="#5714" class="Bound">v2</a><a name="5749">
            </a><a name="5762" class="Symbol">→</a><a name="5763"> </a><a name="5764" href="#5409" class="Datatype">multiSetEq</a><a name="5774"> </a><a name="5775" href="#5714" class="Bound">v2</a><a name="5777"> </a><a name="5778" href="#5717" class="Bound">v3</a><a name="5780"> </a><a name="5781" class="Symbol">→</a><a name="5782"> </a><a name="5783" href="#5409" class="Datatype">multiSetEq</a><a name="5793"> </a><a name="5794" href="#5711" class="Bound">v1</a><a name="5796"> </a><a name="5797" href="#5717" class="Bound">v3</a><a name="5799">

</a><a name="5801" href="#5801" class="Function">multiSetCoRes</a><a name="5814"> </a><a name="5815" class="Symbol">:</a><a name="5816"> </a><a name="5817" class="Symbol">(</a><a name="5818" href="#5818" class="Bound">X</a><a name="5819"> </a><a name="5820" class="Symbol">:</a><a name="5821"> </a><a name="5822" class="PrimitiveType">Set</a><a name="5825" class="Symbol">)</a><a name="5826"> </a><a name="5827" class="Symbol">→</a><a name="5828"> </a><a name="5829" class="Symbol">(</a><a name="5830" href="#5830" class="Bound">n</a><a name="5831"> </a><a name="5832" class="Symbol">:</a><a name="5833"> </a><a name="5834" class="Datatype">ℕ</a><a name="5835" class="Symbol">)</a><a name="5836"> </a><a name="5837" class="Symbol">→</a><a name="5838"> </a><a name="5839" class="Symbol">(</a><a name="5840" href="#4867" class="Function">permActVec</a><a name="5850"> </a><a name="5851" class="Symbol">{</a><a name="5852" href="#5818" class="Bound">X</a><a name="5853" class="Symbol">}</a><a name="5854"> </a><a name="5855" class="Symbol">{</a><a name="5856" href="#5830" class="Bound">n</a><a name="5857" class="Symbol">})</a><a name="5859">
                   </a><a name="5879" class="Function Operator">Preserves₂</a><a name="5889"> </a><a name="5890" class="Function">pEquiv</a><a name="5896"> </a><a name="5897" class="Function Operator">⟶</a><a name="5898"> </a><a name="5899" href="#5409" class="Datatype">multiSetEq</a><a name="5909"> </a><a name="5910" class="Function Operator">⟶</a><a name="5911"> </a><a name="5912" href="#5409" class="Datatype">multiSetEq</a><a name="5922">
</a><a name="5923" href="#5801" class="Function">multiSetCoRes</a><a name="5936"> </a><a name="5937" href="#5937" class="Bound">X</a><a name="5938"> </a><a name="5939" href="#5939" class="Bound">n</a><a name="5940"> </a><a name="5941" class="Symbol">{</a><a name="5942" href="#5942" class="Bound">p1</a><a name="5944" class="Symbol">}</a><a name="5945"> </a><a name="5946" class="Symbol">{</a><a name="5947" href="#5947" class="Bound">p2</a><a name="5949" class="Symbol">}</a><a name="5950"> </a><a name="5951" class="Symbol">{</a><a name="5952" href="#5952" class="Bound">v1</a><a name="5954" class="Symbol">}</a><a name="5955"> </a><a name="5956" class="Symbol">{</a><a name="5957" href="#5957" class="Bound">v2</a><a name="5959" class="Symbol">}</a><a name="5960"> </a><a name="5961" href="#5961" class="Bound">q</a><a name="5962"> </a><a name="5963" href="#5963" class="Bound">r</a><a name="5964"> </a><a name="5965" class="Symbol">=</a><a name="5966"> </a><a name="5967" class="Symbol">{!!}</a><a name="5971">

</a><a name="5973" href="#5973" class="Function">multiSetCop₁p₂↠</a><a name="5988"> </a><a name="5989" class="Symbol">:</a><a name="5990"> </a><a name="5991" class="Symbol">(</a><a name="5992" href="#5992" class="Bound">X</a><a name="5993"> </a><a name="5994" class="Symbol">:</a><a name="5995"> </a><a name="5996" class="PrimitiveType">Set</a><a name="5999" class="Symbol">)</a><a name="6000"> </a><a name="6001" class="Symbol">→</a><a name="6002"> </a><a name="6003" class="Symbol">(</a><a name="6004" href="#6004" class="Bound">n</a><a name="6005"> </a><a name="6006" class="Symbol">:</a><a name="6007"> </a><a name="6008" class="Datatype">ℕ</a><a name="6009" class="Symbol">)</a><a name="6010">
                </a><a name="6027" class="Symbol">→</a><a name="6028"> </a><a name="6029" class="Function">p₁p₂Act</a><a name="6036"> </a><a name="6037" class="Symbol">{</a><a name="6038" class="Function">Perm</a><a name="6042" class="Symbol">}</a><a name="6043"> </a><a name="6044" class="Symbol">{</a><a name="6045" class="Datatype">Vec</a><a name="6048"> </a><a name="6049" href="#5992" class="Bound">X</a><a name="6050"> </a><a name="6051" href="#6004" class="Bound">n</a><a name="6052" class="Symbol">}</a><a name="6053"> </a><a name="6054" class="Symbol">{</a><a name="6055" class="Function Operator">_++_</a><a name="6059" class="Symbol">}</a><a name="6060"> </a><a name="6061" class="Symbol">{</a><a name="6062" href="#5409" class="Datatype">multiSetEq</a><a name="6072" class="Symbol">}</a><a name="6073"> </a><a name="6074" class="Symbol">{</a><a name="6075" href="#4867" class="Function">permActVec</a><a name="6085" class="Symbol">}</a><a name="6086">
</a><a name="6087" href="#5973" class="Function">multiSetCop₁p₂↠</a><a name="6102"> </a><a name="6103" href="#6103" class="Bound">X</a><a name="6104"> </a><a name="6105" href="#6105" class="Bound">n</a><a name="6106"> </a><a name="6107" href="#6107" class="Bound">p1</a><a name="6109"> </a><a name="6110" class="InductiveConstructor">[]</a><a name="6112"> </a><a name="6113" class="Symbol">{</a><a name="6114" href="#6114" class="Bound">v</a><a name="6115" class="Symbol">}</a><a name="6116"> </a><a name="6117" class="Symbol">=</a><a name="6118"> </a><a name="6119" href="#5555" class="InductiveConstructor">reflEq</a><a name="6125">
</a><a name="6126" href="#5973" class="Function">multiSetCop₁p₂↠</a><a name="6141"> </a><a name="6142" href="#6142" class="Bound">X</a><a name="6143"> </a><a name="6144" href="#6144" class="Bound">n</a><a name="6145"> </a><a name="6146" href="#6146" class="Bound">p1</a><a name="6148"> </a><a name="6149" class="Symbol">((</a><a name="6151" href="#6151" class="Bound">a</a><a name="6152"> </a><a name="6153" class="InductiveConstructor Operator">,</a><a name="6154"> </a><a name="6155" href="#6155" class="Bound">b</a><a name="6156" class="Symbol">)</a><a name="6157"> </a><a name="6158" class="InductiveConstructor Operator">::</a><a name="6160"> </a><a name="6161" href="#6161" class="Bound">p2</a><a name="6163" class="Symbol">)</a><a name="6164"> </a><a name="6165" class="Symbol">{</a><a name="6166" href="#6166" class="Bound">v</a><a name="6167" class="Symbol">}</a><a name="6168"> </a><a name="6169" class="Symbol">=</a><a name="6170"> </a><a name="6171" class="Symbol">{!!}</a><a name="6175"> </a><a name="6176" class="Comment">-- annoying to prove, but definitely true</a><a name="6217">

</a><a name="6219" href="#6219" class="Function">multiSet</a><a name="6227"> </a><a name="6228" class="Symbol">:</a><a name="6229"> </a><a name="6230" class="PrimitiveType">Set</a><a name="6233"> </a><a name="6234" class="Symbol">→</a><a name="6235"> </a><a name="6236" class="Datatype">ℕ</a><a name="6237"> </a><a name="6238" class="Symbol">→</a><a name="6239"> </a><a name="6240" href="#2014" class="Record">coNominal</a><a name="6249">
</a><a name="6250" href="#6219" class="Function">multiSet</a><a name="6258"> </a><a name="6259" href="#6259" class="Bound">X</a><a name="6260"> </a><a name="6261" href="#6261" class="Bound">n</a><a name="6262"> </a><a name="6263" class="Symbol">=</a><a name="6264"> </a><a name="6265" class="Keyword">record</a><a name="6271"> </a><a name="6272" class="Symbol">{</a><a name="6273"> </a><a name="6274" class="Field">Aˢ</a><a name="6276"> </a><a name="6277" class="Symbol">=</a><a name="6278"> </a><a name="6279" class="Datatype">Vec</a><a name="6282"> </a><a name="6283" href="#6259" class="Bound">X</a><a name="6284"> </a><a name="6285" href="#6261" class="Bound">n</a><a name="6286">
                      </a><a name="6309" class="Symbol">;</a><a name="6310"> </a><a name="6311" class="Field">≈ᵃ</a><a name="6313"> </a><a name="6314" class="Symbol">=</a><a name="6315"> </a><a name="6316" href="#5409" class="Datatype">multiSetEq</a><a name="6326">
                      </a><a name="6349" class="Symbol">;</a><a name="6350"> </a><a name="6351" class="Field">eq≈ᵃ</a><a name="6355"> </a><a name="6356" class="Symbol">=</a><a name="6357"> </a><a name="6358" class="Keyword">record</a><a name="6364"> </a><a name="6365" class="Symbol">{</a><a name="6366"> </a><a name="6367" class="Field">Reflex</a><a name="6373"> </a><a name="6374" class="Symbol">=</a><a name="6375"> </a><a name="6376" href="#5555" class="InductiveConstructor">reflEq</a><a name="6382">
                                      </a><a name="6421" class="Symbol">;</a><a name="6422"> </a><a name="6423" class="Field">Symm</a><a name="6427"> </a><a name="6428" class="Symbol">=</a><a name="6429"> </a><a name="6430" href="#5605" class="InductiveConstructor">symmEq</a><a name="6436">
                                      </a><a name="6475" class="Symbol">;</a><a name="6476"> </a><a name="6477" class="Field">Trans</a><a name="6482"> </a><a name="6483" class="Symbol">=</a><a name="6484"> </a><a name="6485" href="#5692" class="InductiveConstructor">transEq</a><a name="6492"> </a><a name="6493" class="Symbol">}</a><a name="6494">
                      </a><a name="6517" class="Symbol">;</a><a name="6518"> </a><a name="6519" class="Field">coAct</a><a name="6524"> </a><a name="6525" class="Symbol">=</a><a name="6526"> </a><a name="6527" href="#4867" class="Function">permActVec</a><a name="6537">
                      </a><a name="6560" class="Symbol">;</a><a name="6561"> </a><a name="6562" class="Field">coRes</a><a name="6567"> </a><a name="6568" class="Symbol">=</a><a name="6569"> </a><a name="6570" class="Symbol">{!!}</a><a name="6574"> </a><a name="6575" class="Comment">-- annoying to prove, but definitely true</a><a name="6616">
                      </a><a name="6639" class="Symbol">;</a><a name="6640"> </a><a name="6641" class="Field">cop₁p₂↠</a><a name="6648"> </a><a name="6649" class="Symbol">=</a><a name="6650"> </a><a name="6651" href="#5973" class="Function">multiSetCop₁p₂↠</a><a name="6666"> </a><a name="6667" href="#6259" class="Bound">X</a><a name="6668"> </a><a name="6669" href="#6261" class="Bound">n</a><a name="6670">
                      </a><a name="6693" class="Symbol">;</a><a name="6694"> </a><a name="6695" class="Field">coι↠</a><a name="6699"> </a><a name="6700" class="Symbol">=</a><a name="6701"> </a><a name="6702" href="#5555" class="InductiveConstructor">reflEq</a><a name="6708">
         
                      </a><a name="6741" class="Symbol">;</a><a name="6742"> </a><a name="6743" class="Field">coSupp</a><a name="6749"> </a><a name="6750" class="Symbol">=</a><a name="6751"> </a><a name="6752" href="#3207" class="Function">coSuppVec</a><a name="6761">
                      </a><a name="6784" class="Symbol">;</a><a name="6785"> </a><a name="6786" class="Field">coSuppAx</a><a name="6794"> </a><a name="6795" class="Symbol">=</a><a name="6796"> </a><a name="6797" class="Symbol">λ</a><a name="6798"> </a><a name="6799" href="#6799" class="Bound">a</a><a name="6800"> </a><a name="6801" href="#6801" class="Bound">b</a><a name="6802"> </a><a name="6803" href="#6803" class="Bound">c</a><a name="6804"> </a><a name="6805" href="#6805" class="Bound">_</a><a name="6806"> </a><a name="6807" href="#6807" class="Bound">_</a><a name="6808"> </a><a name="6809" class="Symbol">→</a><a name="6810"> </a><a name="6811" href="#5465" class="InductiveConstructor">swapEq</a><a name="6817"> </a><a name="6818" href="#6801" class="Bound">b</a><a name="6819"> </a><a name="6820" href="#6803" class="Bound">c</a><a name="6821"> </a><a name="6822" class="Symbol">}</a><a name="6823">

</a><a name="6825" class="Keyword">data</a><a name="6829"> </a><a name="6830" href="#6830" class="Datatype">Fin</a><a name="6833"> </a><a name="6834" class="Symbol">:</a><a name="6835"> </a><a name="6836" class="Datatype">ℕ</a><a name="6837"> </a><a name="6838" class="Symbol">→</a><a name="6839"> </a><a name="6840" class="PrimitiveType">Set</a><a name="6843"> </a><a name="6844" class="Keyword">where</a><a name="6849">
  </a><a name="6852" href="#6852" class="InductiveConstructor">zero</a><a name="6856">  </a><a name="6858" class="Symbol">:</a><a name="6859"> </a><a name="6860" class="Symbol">{</a><a name="6861" href="#6861" class="Bound">n</a><a name="6862"> </a><a name="6863" class="Symbol">:</a><a name="6864"> </a><a name="6865" class="Datatype">ℕ</a><a name="6866" class="Symbol">}</a><a name="6867"> </a><a name="6868" class="Symbol">→</a><a name="6869"> </a><a name="6870" href="#6830" class="Datatype">Fin</a><a name="6873"> </a><a name="6874" class="Symbol">(</a><a name="6875" class="InductiveConstructor">succ</a><a name="6879"> </a><a name="6880" href="#6861" class="Bound">n</a><a name="6881" class="Symbol">)</a><a name="6882">
  </a><a name="6885" href="#6885" class="InductiveConstructor">succ</a><a name="6889">  </a><a name="6891" class="Symbol">:</a><a name="6892"> </a><a name="6893" class="Symbol">{</a><a name="6894" href="#6894" class="Bound">n</a><a name="6895"> </a><a name="6896" class="Symbol">:</a><a name="6897"> </a><a name="6898" class="Datatype">ℕ</a><a name="6899" class="Symbol">}</a><a name="6900"> </a><a name="6901" class="Symbol">(</a><a name="6902" href="#6902" class="Bound">i</a><a name="6903"> </a><a name="6904" class="Symbol">:</a><a name="6905"> </a><a name="6906" href="#6830" class="Datatype">Fin</a><a name="6909"> </a><a name="6910" href="#6894" class="Bound">n</a><a name="6911" class="Symbol">)</a><a name="6912"> </a><a name="6913" class="Symbol">→</a><a name="6914"> </a><a name="6915" href="#6830" class="Datatype">Fin</a><a name="6918"> </a><a name="6919" class="Symbol">(</a><a name="6920" class="InductiveConstructor">succ</a><a name="6924"> </a><a name="6925" href="#6894" class="Bound">n</a><a name="6926" class="Symbol">)</a><a name="6927">

</a><a name="6929" href="#6929" class="Function">multiGraph₁</a><a name="6940"> </a><a name="6941" class="Symbol">:</a><a name="6942"> </a><a name="6943" class="Datatype">ℕ</a><a name="6944"> </a><a name="6945" class="Symbol">→</a><a name="6946"> </a><a name="6947" class="Datatype">ℕ</a><a name="6948"> </a><a name="6949" class="Symbol">→</a><a name="6950"> </a><a name="6951" href="#2014" class="Record">coNominal</a><a name="6960">
</a><a name="6961" href="#6929" class="Function">multiGraph₁</a><a name="6972"> </a><a name="6973" href="#6973" class="Bound">n</a><a name="6974"> </a><a name="6975" class="Symbol">=</a><a name="6976"> </a><a name="6977" href="#6219" class="Function">multiSet</a><a name="6985"> </a><a name="6986" class="Symbol">((</a><a name="6988" href="#6830" class="Datatype">Fin</a><a name="6991"> </a><a name="6992" href="#6973" class="Bound">n</a><a name="6993" class="Symbol">)</a><a name="6994"> </a><a name="6995" class="Function Operator">×</a><a name="6996"> </a><a name="6997" class="Symbol">(</a><a name="6998" href="#6830" class="Datatype">Fin</a><a name="7001"> </a><a name="7002" href="#6973" class="Bound">n</a><a name="7003" class="Symbol">))</a></code></pre>
<p><code>multiGraph₁</code> is a coNominal set representing multigraphs, indexed by both the number of vertices and edges, quotiented so that the order of the edges in the list of edges makes no difference; however, to have a fully abstract notion of multigraph, we must also equate all multigraphs that have the same shape with different labels associated with each node.</p>
<pre class="Agda"><code><a name="7376">
</a><a name="7392" href="#7392" class="Function">coSuppFin</a><a name="7401"> </a><a name="7402" class="Symbol">:</a><a name="7403"> </a><a name="7404" class="Datatype">ℕ</a><a name="7405"> </a><a name="7406" class="Symbol">→</a><a name="7407"> </a><a name="7408" class="Datatype">List</a><a name="7412"> </a><a name="7413" class="Datatype">Atom</a><a name="7417">
</a><a name="7418" href="#7392" class="Function">coSuppFin</a><a name="7427"> </a><a name="7428" class="InductiveConstructor">zero</a><a name="7432"> </a><a name="7433" class="Symbol">=</a><a name="7434"> </a><a name="7435" class="InductiveConstructor">[]</a><a name="7437">
</a><a name="7438" href="#7392" class="Function">coSuppFin</a><a name="7447"> </a><a name="7448" class="Symbol">(</a><a name="7449" class="InductiveConstructor">succ</a><a name="7453"> </a><a name="7454" href="#7454" class="Bound">n</a><a name="7455" class="Symbol">)</a><a name="7456"> </a><a name="7457" class="Symbol">=</a><a name="7458"> </a><a name="7459" href="#3101" class="Function">AtListSucc</a><a name="7469"> </a><a name="7470" class="Symbol">(</a><a name="7471" href="#7392" class="Function">coSuppFin</a><a name="7480"> </a><a name="7481" href="#7454" class="Bound">n</a><a name="7482" class="Symbol">)</a><a name="7483">

</a><a name="7485" href="#7485" class="Function">toℕ</a><a name="7488"> </a><a name="7489" class="Symbol">:</a><a name="7490"> </a><a name="7491" class="Symbol">{</a><a name="7492" href="#7492" class="Bound">n</a><a name="7493"> </a><a name="7494" class="Symbol">:</a><a name="7495"> </a><a name="7496" class="Datatype">ℕ</a><a name="7497" class="Symbol">}</a><a name="7498"> </a><a name="7499" class="Symbol">→</a><a name="7500"> </a><a name="7501" href="#6830" class="Datatype">Fin</a><a name="7504"> </a><a name="7505" href="#7492" class="Bound">n</a><a name="7506"> </a><a name="7507" class="Symbol">→</a><a name="7508"> </a><a name="7509" class="Datatype">ℕ</a><a name="7510">
</a><a name="7511" href="#7485" class="Function">toℕ</a><a name="7514"> </a><a name="7515" href="#6852" class="InductiveConstructor">zero</a><a name="7519"> </a><a name="7520" class="Symbol">=</a><a name="7521"> </a><a name="7522" class="InductiveConstructor">zero</a><a name="7526">
</a><a name="7527" href="#7485" class="Function">toℕ</a><a name="7530"> </a><a name="7531" class="Symbol">(</a><a name="7532" href="#6885" class="InductiveConstructor">succ</a><a name="7536"> </a><a name="7537" href="#7537" class="Bound">f</a><a name="7538" class="Symbol">)</a><a name="7539"> </a><a name="7540" class="Symbol">=</a><a name="7541"> </a><a name="7542" class="InductiveConstructor">succ</a><a name="7546"> </a><a name="7547" class="Symbol">(</a><a name="7548" href="#7485" class="Function">toℕ</a><a name="7551"> </a><a name="7552" href="#7537" class="Bound">f</a><a name="7553" class="Symbol">)</a><a name="7554">

</a><a name="7556" href="#7556" class="Function">pred</a><a name="7560"> </a><a name="7561" class="Symbol">:</a><a name="7562"> </a><a name="7563" class="Datatype">ℕ</a><a name="7564"> </a><a name="7565" class="Symbol">→</a><a name="7566"> </a><a name="7567" class="Datatype">ℕ</a><a name="7568">
</a><a name="7569" href="#7556" class="Function">pred</a><a name="7573"> </a><a name="7574" class="InductiveConstructor">zero</a><a name="7578">     </a><a name="7583" class="Symbol">=</a><a name="7584"> </a><a name="7585" class="InductiveConstructor">zero</a><a name="7589">
</a><a name="7590" href="#7556" class="Function">pred</a><a name="7594"> </a><a name="7595" class="Symbol">(</a><a name="7596" class="InductiveConstructor">succ</a><a name="7600"> </a><a name="7601" href="#7601" class="Bound">n</a><a name="7602" class="Symbol">)</a><a name="7603"> </a><a name="7604" class="Symbol">=</a><a name="7605"> </a><a name="7606" href="#7601" class="Bound">n</a><a name="7607">

</a><a name="7609" href="#7609" class="Function">decEqNat</a><a name="7617"> </a><a name="7618" class="Symbol">:</a><a name="7619"> </a><a name="7620" class="Symbol">(</a><a name="7621" href="#7621" class="Bound">m</a><a name="7622"> </a><a name="7623" href="#7623" class="Bound">n</a><a name="7624"> </a><a name="7625" class="Symbol">:</a><a name="7626"> </a><a name="7627" class="Datatype">ℕ</a><a name="7628" class="Symbol">)</a><a name="7629"> </a><a name="7630" class="Symbol">→</a><a name="7631"> </a><a name="7632" class="Datatype">Dec</a><a name="7635"> </a><a name="7636" class="Symbol">(</a><a name="7637" href="#7621" class="Bound">m</a><a name="7638"> </a><a name="7639" class="Datatype Operator">≡</a><a name="7640"> </a><a name="7641" href="#7623" class="Bound">n</a><a name="7642" class="Symbol">)</a><a name="7643">
</a><a name="7644" href="#7609" class="Function">decEqNat</a><a name="7652"> </a><a name="7653" class="InductiveConstructor">zero</a><a name="7657"> </a><a name="7658" class="InductiveConstructor">zero</a><a name="7662"> </a><a name="7663" class="Symbol">=</a><a name="7664"> </a><a name="7665" class="InductiveConstructor">yes</a><a name="7668"> </a><a name="7669" class="InductiveConstructor">refl</a><a name="7673">
</a><a name="7674" href="#7609" class="Function">decEqNat</a><a name="7682"> </a><a name="7683" class="InductiveConstructor">zero</a><a name="7687"> </a><a name="7688" class="Symbol">(</a><a name="7689" class="InductiveConstructor">succ</a><a name="7693"> </a><a name="7694" href="#7694" class="Bound">n</a><a name="7695" class="Symbol">)</a><a name="7696"> </a><a name="7697" class="Symbol">=</a><a name="7698"> </a><a name="7699" class="InductiveConstructor">no</a><a name="7701"> </a><a name="7702" class="Symbol">(λ</a><a name="7704"> </a><a name="7705" class="Symbol">())</a><a name="7708">
</a><a name="7709" href="#7609" class="Function">decEqNat</a><a name="7717"> </a><a name="7718" class="Symbol">(</a><a name="7719" class="InductiveConstructor">succ</a><a name="7723"> </a><a name="7724" href="#7724" class="Bound">m</a><a name="7725" class="Symbol">)</a><a name="7726"> </a><a name="7727" class="InductiveConstructor">zero</a><a name="7731"> </a><a name="7732" class="Symbol">=</a><a name="7733"> </a><a name="7734" class="InductiveConstructor">no</a><a name="7736"> </a><a name="7737" class="Symbol">(λ</a><a name="7739"> </a><a name="7740" class="Symbol">())</a><a name="7743">
</a><a name="7744" href="#7609" class="Function">decEqNat</a><a name="7752"> </a><a name="7753" class="Symbol">(</a><a name="7754" class="InductiveConstructor">succ</a><a name="7758"> </a><a name="7759" href="#7759" class="Bound">m</a><a name="7760" class="Symbol">)</a><a name="7761"> </a><a name="7762" class="Symbol">(</a><a name="7763" class="InductiveConstructor">succ</a><a name="7767"> </a><a name="7768" href="#7768" class="Bound">n</a><a name="7769" class="Symbol">)</a><a name="7770"> </a><a name="7771" class="Keyword">with</a><a name="7775"> </a><a name="7776" href="#7609" class="Function">decEqNat</a><a name="7784"> </a><a name="7785" href="#7759" class="Bound">m</a><a name="7786"> </a><a name="7787" href="#7768" class="Bound">n</a><a name="7788">
</a><a name="7789" href="#7609" class="Function">decEqNat</a><a name="7797"> </a><a name="7798" class="Symbol">(</a><a name="7799" class="InductiveConstructor">succ</a><a name="7803"> </a><a name="7804" href="#7804" class="Bound">m</a><a name="7805" class="Symbol">)</a><a name="7806"> </a><a name="7807" class="Symbol">(</a><a name="7808" class="InductiveConstructor">succ</a><a name="7812"> </a><a name="7813" class="DottedPattern Symbol">.</a><a name="7814" href="#7804" class="DottedPattern Bound">m</a><a name="7815" class="Symbol">)</a><a name="7816"> </a><a name="7817" class="Symbol">|</a><a name="7818"> </a><a name="7819" class="InductiveConstructor">yes</a><a name="7822"> </a><a name="7823" class="InductiveConstructor">refl</a><a name="7827"> </a><a name="7828" class="Symbol">=</a><a name="7829"> </a><a name="7830" class="InductiveConstructor">yes</a><a name="7833"> </a><a name="7834" class="InductiveConstructor">refl</a><a name="7838">
</a><a name="7839" href="#7609" class="Function">decEqNat</a><a name="7847"> </a><a name="7848" class="Symbol">(</a><a name="7849" class="InductiveConstructor">succ</a><a name="7853"> </a><a name="7854" href="#7854" class="Bound">m</a><a name="7855" class="Symbol">)</a><a name="7856"> </a><a name="7857" class="Symbol">(</a><a name="7858" class="InductiveConstructor">succ</a><a name="7862">  </a><a name="7864" href="#7864" class="Bound">n</a><a name="7865" class="Symbol">)</a><a name="7866"> </a><a name="7867" class="Symbol">|</a><a name="7868"> </a><a name="7869" class="InductiveConstructor">no</a><a name="7871">  </a><a name="7873" href="#7873" class="Bound">p</a><a name="7874">    </a><a name="7878" class="Symbol">=</a><a name="7879"> </a><a name="7880" class="InductiveConstructor">no</a><a name="7882"> </a><a name="7883" class="Symbol">((</a><a name="7885" href="#7873" class="Bound">p</a><a name="7886"> </a><a name="7887" class="Function Operator">∘</a><a name="7888"> </a><a name="7889" class="Function">cong</a><a name="7893"> </a><a name="7894" href="#7556" class="Function">pred</a><a name="7898" class="Symbol">))</a><a name="7900">

</a><a name="7902" href="#7902" class="Function">AtoFin</a><a name="7908"> </a><a name="7909" class="Symbol">:</a><a name="7910"> </a><a name="7911" class="Symbol">{</a><a name="7912" href="#7912" class="Bound">n</a><a name="7913"> </a><a name="7914" class="Symbol">:</a><a name="7915"> </a><a name="7916" class="Datatype">ℕ</a><a name="7917" class="Symbol">}</a><a name="7918"> </a><a name="7919" class="Symbol">→</a><a name="7920"> </a><a name="7921" class="Symbol">(</a><a name="7922" href="#7922" class="Bound">a</a><a name="7923"> </a><a name="7924" class="Symbol">:</a><a name="7925"> </a><a name="7926" class="Datatype">Atom</a><a name="7930" class="Symbol">)</a><a name="7931"> </a><a name="7932" class="Symbol">→</a><a name="7933"> </a><a name="7934" class="Symbol">(</a><a name="7935" class="InductiveConstructor">succ</a><a name="7939"> </a><a name="7940" class="Symbol">(</a><a name="7941" href="#3033" class="Function">Atoℕ</a><a name="7945"> </a><a name="7946" href="#7922" class="Bound">a</a><a name="7947" class="Symbol">))</a><a name="7949"> </a><a name="7950" href="#2537" class="Datatype Operator">≤</a><a name="7951"> </a><a name="7952" href="#7912" class="Bound">n</a><a name="7953"> </a><a name="7954" class="Symbol">→</a><a name="7955"> </a><a name="7956" href="#6830" class="Datatype">Fin</a><a name="7959"> </a><a name="7960" href="#7912" class="Bound">n</a><a name="7961">
</a><a name="7962" href="#7902" class="Function">AtoFin</a><a name="7968"> </a><a name="7969" class="Symbol">{</a><a name="7970" class="InductiveConstructor">zero</a><a name="7974" class="Symbol">}</a><a name="7975"> </a><a name="7976" href="#7976" class="Bound">a</a><a name="7977"> </a><a name="7978" class="Symbol">()</a><a name="7980">
</a><a name="7981" href="#7902" class="Function">AtoFin</a><a name="7987"> </a><a name="7988" class="Symbol">{</a><a name="7989" class="InductiveConstructor">succ</a><a name="7993"> </a><a name="7994" href="#7994" class="Bound">n</a><a name="7995" class="Symbol">}</a><a name="7996"> </a><a name="7997" class="InductiveConstructor">root</a><a name="8001"> </a><a name="8002" href="#8002" class="Bound">p</a><a name="8003"> </a><a name="8004" class="Symbol">=</a><a name="8005"> </a><a name="8006" href="#6852" class="InductiveConstructor">zero</a><a name="8010">
</a><a name="8011" href="#7902" class="Function">AtoFin</a><a name="8017"> </a><a name="8018" class="Symbol">{</a><a name="8019" class="InductiveConstructor">succ</a><a name="8023"> </a><a name="8024" href="#8024" class="Bound">n</a><a name="8025" class="Symbol">}</a><a name="8026"> </a><a name="8027" class="Symbol">(</a><a name="8028" class="InductiveConstructor">next</a><a name="8032"> </a><a name="8033" href="#8033" class="Bound">a</a><a name="8034" class="Symbol">)</a><a name="8035"> </a><a name="8036" class="Symbol">(</a><a name="8037" href="#2592" class="InductiveConstructor">≤succ</a><a name="8042"> </a><a name="8043" href="#8043" class="Bound">p</a><a name="8044" class="Symbol">)</a><a name="8045"> </a><a name="8046" class="Symbol">=</a><a name="8047"> </a><a name="8048" href="#6885" class="InductiveConstructor">succ</a><a name="8052"> </a><a name="8053" class="Symbol">(</a><a name="8054" href="#7902" class="Function">AtoFin</a><a name="8060"> </a><a name="8061" class="Symbol">{</a><a name="8062" href="#8024" class="Bound">n</a><a name="8063" class="Symbol">}</a><a name="8064"> </a><a name="8065" href="#8033" class="Bound">a</a><a name="8066"> </a><a name="8067" href="#8043" class="Bound">p</a><a name="8068" class="Symbol">)</a><a name="8069">

</a><a name="8071" href="#8071" class="Function">swapFin</a><a name="8078"> </a><a name="8079" class="Symbol">:</a><a name="8080"> </a><a name="8081" class="Symbol">{</a><a name="8082" href="#8082" class="Bound">n</a><a name="8083"> </a><a name="8084" class="Symbol">:</a><a name="8085"> </a><a name="8086" class="Datatype">ℕ</a><a name="8087" class="Symbol">}</a><a name="8088"> </a><a name="8089" class="Symbol">→</a><a name="8090"> </a><a name="8091" class="Datatype">Atom</a><a name="8095"> </a><a name="8096" class="Symbol">→</a><a name="8097"> </a><a name="8098" class="Datatype">Atom</a><a name="8102"> </a><a name="8103" class="Symbol">→</a><a name="8104"> </a><a name="8105" href="#6830" class="Datatype">Fin</a><a name="8108"> </a><a name="8109" href="#8082" class="Bound">n</a><a name="8110"> </a><a name="8111" class="Symbol">→</a><a name="8112"> </a><a name="8113" href="#6830" class="Datatype">Fin</a><a name="8116"> </a><a name="8117" href="#8082" class="Bound">n</a><a name="8118">
</a><a name="8119" href="#8071" class="Function">swapFin</a><a name="8126"> </a><a name="8127" class="Symbol">{</a><a name="8128" href="#8128" class="Bound">n</a><a name="8129" class="Symbol">}</a><a name="8130"> </a><a name="8131" href="#8131" class="Bound">a</a><a name="8132"> </a><a name="8133" href="#8133" class="Bound">b</a><a name="8134"> </a><a name="8135" href="#8135" class="Bound">f</a><a name="8136"> </a><a name="8137" class="Keyword">with</a><a name="8141"> </a><a name="8142" href="#2756" class="Function">dec≤</a><a name="8146"> </a><a name="8147" class="Symbol">(</a><a name="8148" class="InductiveConstructor">succ</a><a name="8152"> </a><a name="8153" class="Symbol">(</a><a name="8154" href="#3033" class="Function">Atoℕ</a><a name="8158"> </a><a name="8159" href="#8131" class="Bound">a</a><a name="8160" class="Symbol">))</a><a name="8162"> </a><a name="8163" href="#8128" class="Bound">n</a><a name="8164"> </a><a name="8165" class="Symbol">|</a><a name="8166"> </a><a name="8167" href="#2756" class="Function">dec≤</a><a name="8171"> </a><a name="8172" class="Symbol">(</a><a name="8173" class="InductiveConstructor">succ</a><a name="8177"> </a><a name="8178" class="Symbol">(</a><a name="8179" href="#3033" class="Function">Atoℕ</a><a name="8183"> </a><a name="8184" href="#8133" class="Bound">b</a><a name="8185" class="Symbol">))</a><a name="8187"> </a><a name="8188" href="#8128" class="Bound">n</a><a name="8189">
</a><a name="8190" href="#8071" class="Function">swapFin</a><a name="8197"> </a><a name="8198" href="#8198" class="Bound">a</a><a name="8199"> </a><a name="8200" href="#8200" class="Bound">b</a><a name="8201"> </a><a name="8202" href="#8202" class="Bound">f</a><a name="8203"> </a><a name="8204" class="Symbol">|</a><a name="8205"> </a><a name="8206" class="InductiveConstructor">yes</a><a name="8209"> </a><a name="8210" href="#8210" class="Bound">p</a><a name="8211"> </a><a name="8212" class="Symbol">|</a><a name="8213"> </a><a name="8214" class="InductiveConstructor">yes</a><a name="8217"> </a><a name="8218" href="#8218" class="Bound">q</a><a name="8219"> </a><a name="8220" class="Keyword">with</a><a name="8224"> </a><a name="8225" href="#7609" class="Function">decEqNat</a><a name="8233"> </a><a name="8234" class="Symbol">(</a><a name="8235" href="#3033" class="Function">Atoℕ</a><a name="8239"> </a><a name="8240" href="#8198" class="Bound">a</a><a name="8241" class="Symbol">)</a><a name="8242"> </a><a name="8243" class="Symbol">(</a><a name="8244" href="#7485" class="Function">toℕ</a><a name="8247"> </a><a name="8248" href="#8202" class="Bound">f</a><a name="8249" class="Symbol">)</a><a name="8250">
                                 </a><a name="8284" class="Symbol">|</a><a name="8285"> </a><a name="8286" href="#7609" class="Function">decEqNat</a><a name="8294"> </a><a name="8295" class="Symbol">(</a><a name="8296" href="#3033" class="Function">Atoℕ</a><a name="8300"> </a><a name="8301" href="#8200" class="Bound">b</a><a name="8302" class="Symbol">)</a><a name="8303"> </a><a name="8304" class="Symbol">(</a><a name="8305" href="#7485" class="Function">toℕ</a><a name="8308"> </a><a name="8309" href="#8202" class="Bound">f</a><a name="8310" class="Symbol">)</a><a name="8311">
</a><a name="8312" href="#8071" class="Function">swapFin</a><a name="8319"> </a><a name="8320" href="#8320" class="Bound">a</a><a name="8321"> </a><a name="8322" href="#8322" class="Bound">b</a><a name="8323"> </a><a name="8324" href="#8324" class="Bound">f</a><a name="8325"> </a><a name="8326" class="Symbol">|</a><a name="8327"> </a><a name="8328" class="InductiveConstructor">yes</a><a name="8331"> </a><a name="8332" href="#8332" class="Bound">p</a><a name="8333"> </a><a name="8334" class="Symbol">|</a><a name="8335"> </a><a name="8336" class="InductiveConstructor">yes</a><a name="8339"> </a><a name="8340" href="#8340" class="Bound">q</a><a name="8341"> </a><a name="8342" class="Symbol">|</a><a name="8343"> </a><a name="8344" class="InductiveConstructor">yes</a><a name="8347"> </a><a name="8348" href="#8348" class="Bound">r</a><a name="8349"> </a><a name="8350" class="Symbol">|</a><a name="8351"> </a><a name="8352" class="Symbol">_</a><a name="8353">     </a><a name="8358" class="Symbol">=</a><a name="8359"> </a><a name="8360" href="#7902" class="Function">AtoFin</a><a name="8366"> </a><a name="8367" href="#8322" class="Bound">b</a><a name="8368"> </a><a name="8369" href="#8340" class="Bound">q</a><a name="8370">
</a><a name="8371" href="#8071" class="Function">swapFin</a><a name="8378"> </a><a name="8379" href="#8379" class="Bound">a</a><a name="8380"> </a><a name="8381" href="#8381" class="Bound">b</a><a name="8382"> </a><a name="8383" href="#8383" class="Bound">f</a><a name="8384"> </a><a name="8385" class="Symbol">|</a><a name="8386"> </a><a name="8387" class="InductiveConstructor">yes</a><a name="8390"> </a><a name="8391" href="#8391" class="Bound">p</a><a name="8392"> </a><a name="8393" class="Symbol">|</a><a name="8394"> </a><a name="8395" class="InductiveConstructor">yes</a><a name="8398"> </a><a name="8399" href="#8399" class="Bound">q</a><a name="8400"> </a><a name="8401" class="Symbol">|</a><a name="8402"> </a><a name="8403" class="Symbol">_</a><a name="8404">     </a><a name="8409" class="Symbol">|</a><a name="8410"> </a><a name="8411" class="InductiveConstructor">yes</a><a name="8414"> </a><a name="8415" href="#8415" class="Bound">r</a><a name="8416"> </a><a name="8417" class="Symbol">=</a><a name="8418"> </a><a name="8419" href="#7902" class="Function">AtoFin</a><a name="8425"> </a><a name="8426" href="#8379" class="Bound">a</a><a name="8427"> </a><a name="8428" href="#8391" class="Bound">p</a><a name="8429">
</a><a name="8430" href="#8071" class="Function">swapFin</a><a name="8437"> </a><a name="8438" href="#8438" class="Bound">a</a><a name="8439"> </a><a name="8440" href="#8440" class="Bound">b</a><a name="8441"> </a><a name="8442" href="#8442" class="Bound">f</a><a name="8443"> </a><a name="8444" class="Symbol">|</a><a name="8445"> </a><a name="8446" class="InductiveConstructor">yes</a><a name="8449"> </a><a name="8450" href="#8450" class="Bound">p</a><a name="8451"> </a><a name="8452" class="Symbol">|</a><a name="8453"> </a><a name="8454" class="InductiveConstructor">yes</a><a name="8457"> </a><a name="8458" href="#8458" class="Bound">q</a><a name="8459"> </a><a name="8460" class="Symbol">|</a><a name="8461"> </a><a name="8462" class="Symbol">_</a><a name="8463">     </a><a name="8468" class="Symbol">|</a><a name="8469"> </a><a name="8470" class="Symbol">_</a><a name="8471">     </a><a name="8476" class="Symbol">=</a><a name="8477"> </a><a name="8478" href="#8442" class="Bound">f</a><a name="8479">
</a><a name="8480" href="#8071" class="Function">swapFin</a><a name="8487"> </a><a name="8488" href="#8488" class="Bound">a</a><a name="8489"> </a><a name="8490" href="#8490" class="Bound">b</a><a name="8491"> </a><a name="8492" href="#8492" class="Bound">f</a><a name="8493"> </a><a name="8494" class="Symbol">|</a><a name="8495"> </a><a name="8496" class="Symbol">_</a><a name="8497">     </a><a name="8502" class="Symbol">|</a><a name="8503"> </a><a name="8504" class="Symbol">_</a><a name="8505">     </a><a name="8510" class="Symbol">=</a><a name="8511"> </a><a name="8512" href="#8492" class="Bound">f</a><a name="8513">

</a><a name="8515" href="#8515" class="Function">swapVecFin</a><a name="8525"> </a><a name="8526" class="Symbol">:</a><a name="8527"> </a><a name="8528" class="Symbol">{</a><a name="8529" href="#8529" class="Bound">v</a><a name="8530"> </a><a name="8531" href="#8531" class="Bound">e</a><a name="8532"> </a><a name="8533" class="Symbol">:</a><a name="8534"> </a><a name="8535" class="Datatype">ℕ</a><a name="8536" class="Symbol">}</a><a name="8537"> </a><a name="8538" class="Symbol">→</a><a name="8539"> </a><a name="8540" class="Datatype">Atom</a><a name="8544"> </a><a name="8545" class="Symbol">→</a><a name="8546"> </a><a name="8547" class="Datatype">Atom</a><a name="8551"> </a><a name="8552" class="Symbol">→</a><a name="8553"> </a><a name="8554" class="Datatype">Vec</a><a name="8557"> </a><a name="8558" class="Symbol">((</a><a name="8560" href="#6830" class="Datatype">Fin</a><a name="8563"> </a><a name="8564" href="#8529" class="Bound">v</a><a name="8565" class="Symbol">)</a><a name="8566"> </a><a name="8567" class="Function Operator">×</a><a name="8568"> </a><a name="8569" class="Symbol">(</a><a name="8570" href="#6830" class="Datatype">Fin</a><a name="8573"> </a><a name="8574" href="#8529" class="Bound">v</a><a name="8575" class="Symbol">))</a><a name="8577"> </a><a name="8578" href="#8531" class="Bound">e</a><a name="8579">
             </a><a name="8593" class="Symbol">→</a><a name="8594"> </a><a name="8595" class="Datatype">Vec</a><a name="8598"> </a><a name="8599" class="Symbol">((</a><a name="8601" href="#6830" class="Datatype">Fin</a><a name="8604"> </a><a name="8605" href="#8529" class="Bound">v</a><a name="8606" class="Symbol">)</a><a name="8607"> </a><a name="8608" class="Function Operator">×</a><a name="8609"> </a><a name="8610" class="Symbol">(</a><a name="8611" href="#6830" class="Datatype">Fin</a><a name="8614"> </a><a name="8615" href="#8529" class="Bound">v</a><a name="8616" class="Symbol">))</a><a name="8618"> </a><a name="8619" href="#8531" class="Bound">e</a><a name="8620">
</a><a name="8621" href="#8515" class="Function">swapVecFin</a><a name="8631"> </a><a name="8632" href="#8632" class="Bound">a</a><a name="8633"> </a><a name="8634" href="#8634" class="Bound">b</a><a name="8635"> </a><a name="8636" class="InductiveConstructor">[]</a><a name="8638"> </a><a name="8639" class="Symbol">=</a><a name="8640"> </a><a name="8641" class="InductiveConstructor">[]</a><a name="8643">
</a><a name="8644" href="#8515" class="Function">swapVecFin</a><a name="8654"> </a><a name="8655" class="Symbol">{</a><a name="8656" href="#8656" class="Bound">v</a><a name="8657" class="Symbol">}</a><a name="8658"> </a><a name="8659" href="#8659" class="Bound">a</a><a name="8660"> </a><a name="8661" href="#8661" class="Bound">b</a><a name="8662"> </a><a name="8663" class="Symbol">((</a><a name="8665" href="#8665" class="Bound">x</a><a name="8666"> </a><a name="8667" class="InductiveConstructor Operator">,</a><a name="8668"> </a><a name="8669" href="#8669" class="Bound">y</a><a name="8670" class="Symbol">)</a><a name="8671"> </a><a name="8672" class="InductiveConstructor Operator">::</a><a name="8674"> </a><a name="8675" href="#8675" class="Bound">g</a><a name="8676" class="Symbol">)</a><a name="8677"> </a><a name="8678" class="Keyword">with</a><a name="8682"> </a><a name="8683" href="#2756" class="Function">dec≤</a><a name="8687"> </a><a name="8688" class="Symbol">(</a><a name="8689" class="InductiveConstructor">succ</a><a name="8693"> </a><a name="8694" class="Symbol">(</a><a name="8695" href="#3033" class="Function">Atoℕ</a><a name="8699"> </a><a name="8700" href="#8659" class="Bound">a</a><a name="8701" class="Symbol">))</a><a name="8703"> </a><a name="8704" href="#8656" class="Bound">v</a><a name="8705">
                                     </a><a name="8743" class="Symbol">|</a><a name="8744"> </a><a name="8745" href="#2756" class="Function">dec≤</a><a name="8749"> </a><a name="8750" class="Symbol">(</a><a name="8751" class="InductiveConstructor">succ</a><a name="8755"> </a><a name="8756" class="Symbol">(</a><a name="8757" href="#3033" class="Function">Atoℕ</a><a name="8761"> </a><a name="8762" href="#8661" class="Bound">b</a><a name="8763" class="Symbol">))</a><a name="8765"> </a><a name="8766" href="#8656" class="Bound">v</a><a name="8767">
</a><a name="8768" href="#8515" class="Function">swapVecFin</a><a name="8778"> </a><a name="8779" href="#8779" class="Bound">a</a><a name="8780"> </a><a name="8781" href="#8781" class="Bound">b</a><a name="8782"> </a><a name="8783" class="Symbol">((</a><a name="8785" href="#8785" class="Bound">x</a><a name="8786"> </a><a name="8787" class="InductiveConstructor Operator">,</a><a name="8788"> </a><a name="8789" href="#8789" class="Bound">y</a><a name="8790" class="Symbol">)</a><a name="8791"> </a><a name="8792" class="InductiveConstructor Operator">::</a><a name="8794"> </a><a name="8795" href="#8795" class="Bound">g</a><a name="8796" class="Symbol">)</a><a name="8797"> </a><a name="8798" class="Symbol">|</a><a name="8799"> </a><a name="8800" class="InductiveConstructor">yes</a><a name="8803"> </a><a name="8804" href="#8804" class="Bound">p</a><a name="8805"> </a><a name="8806" class="Symbol">|</a><a name="8807"> </a><a name="8808" class="InductiveConstructor">yes</a><a name="8811"> </a><a name="8812" href="#8812" class="Bound">q</a><a name="8813">
                              </a><a name="8844" class="Symbol">=</a><a name="8845"> </a><a name="8846" class="Symbol">(</a><a name="8847" href="#8071" class="Function">swapFin</a><a name="8854"> </a><a name="8855" href="#8779" class="Bound">a</a><a name="8856"> </a><a name="8857" href="#8781" class="Bound">b</a><a name="8858"> </a><a name="8859" href="#8785" class="Bound">x</a><a name="8860"> </a><a name="8861" class="InductiveConstructor Operator">,</a><a name="8862"> </a><a name="8863" href="#8071" class="Function">swapFin</a><a name="8870"> </a><a name="8871" href="#8779" class="Bound">a</a><a name="8872"> </a><a name="8873" href="#8781" class="Bound">b</a><a name="8874"> </a><a name="8875" href="#8789" class="Bound">y</a><a name="8876" class="Symbol">)</a><a name="8877"> </a><a name="8878" class="InductiveConstructor Operator">::</a><a name="8880"> </a><a name="8881" class="Symbol">(</a><a name="8882" href="#8515" class="Function">swapVecFin</a><a name="8892"> </a><a name="8893" href="#8779" class="Bound">a</a><a name="8894"> </a><a name="8895" href="#8781" class="Bound">b</a><a name="8896"> </a><a name="8897" href="#8795" class="Bound">g</a><a name="8898" class="Symbol">)</a><a name="8899"> 
</a><a name="8901" href="#8515" class="Function">swapVecFin</a><a name="8911"> </a><a name="8912" href="#8912" class="Bound">a</a><a name="8913"> </a><a name="8914" href="#8914" class="Bound">b</a><a name="8915"> </a><a name="8916" class="Symbol">((</a><a name="8918" href="#8918" class="Bound">x</a><a name="8919"> </a><a name="8920" class="InductiveConstructor Operator">,</a><a name="8921"> </a><a name="8922" href="#8922" class="Bound">y</a><a name="8923" class="Symbol">)</a><a name="8924"> </a><a name="8925" class="InductiveConstructor Operator">::</a><a name="8927"> </a><a name="8928" href="#8928" class="Bound">g</a><a name="8929" class="Symbol">)</a><a name="8930"> </a><a name="8931" class="Symbol">|</a><a name="8932"> </a><a name="8933" class="Symbol">_</a><a name="8934">     </a><a name="8939" class="Symbol">|</a><a name="8940"> </a><a name="8941" class="Symbol">_</a><a name="8942">     </a><a name="8947" class="Symbol">=</a><a name="8948"> </a><a name="8949" class="Symbol">((</a><a name="8951" href="#8918" class="Bound">x</a><a name="8952"> </a><a name="8953" class="InductiveConstructor Operator">,</a><a name="8954"> </a><a name="8955" href="#8922" class="Bound">y</a><a name="8956" class="Symbol">)</a><a name="8957"> </a><a name="8958" class="InductiveConstructor Operator">::</a><a name="8960"> </a><a name="8961" href="#8928" class="Bound">g</a><a name="8962" class="Symbol">)</a><a name="8963">

 
</a><a name="8967" href="#8967" class="Function">permActFin</a><a name="8977"> </a><a name="8978" class="Symbol">:</a><a name="8979"> </a><a name="8980" class="Symbol">{</a><a name="8981" href="#8981" class="Bound">v</a><a name="8982"> </a><a name="8983" href="#8983" class="Bound">e</a><a name="8984"> </a><a name="8985" class="Symbol">:</a><a name="8986"> </a><a name="8987" class="Datatype">ℕ</a><a name="8988" class="Symbol">}</a><a name="8989"> </a><a name="8990" class="Symbol">→</a><a name="8991"> </a><a name="8992" class="Function">Perm</a><a name="8996"> </a><a name="8997" class="Symbol">→</a><a name="8998"> </a><a name="8999" class="Datatype">Vec</a><a name="9002"> </a><a name="9003" class="Symbol">((</a><a name="9005" href="#6830" class="Datatype">Fin</a><a name="9008"> </a><a name="9009" href="#8981" class="Bound">v</a><a name="9010" class="Symbol">)</a><a name="9011"> </a><a name="9012" class="Function Operator">×</a><a name="9013"> </a><a name="9014" class="Symbol">(</a><a name="9015" href="#6830" class="Datatype">Fin</a><a name="9018"> </a><a name="9019" href="#8981" class="Bound">v</a><a name="9020" class="Symbol">))</a><a name="9022"> </a><a name="9023" href="#8983" class="Bound">e</a><a name="9024">
                              </a><a name="9055" class="Symbol">→</a><a name="9056"> </a><a name="9057" class="Datatype">Vec</a><a name="9060"> </a><a name="9061" class="Symbol">((</a><a name="9063" href="#6830" class="Datatype">Fin</a><a name="9066"> </a><a name="9067" href="#8981" class="Bound">v</a><a name="9068" class="Symbol">)</a><a name="9069"> </a><a name="9070" class="Function Operator">×</a><a name="9071"> </a><a name="9072" class="Symbol">(</a><a name="9073" href="#6830" class="Datatype">Fin</a><a name="9076"> </a><a name="9077" href="#8981" class="Bound">v</a><a name="9078" class="Symbol">))</a><a name="9080"> </a><a name="9081" href="#8983" class="Bound">e</a><a name="9082">
</a><a name="9083" href="#8967" class="Function">permActFin</a><a name="9093"> </a><a name="9094" class="InductiveConstructor">[]</a><a name="9096"> </a><a name="9097" href="#9097" class="Bound">v</a><a name="9098"> </a><a name="9099" class="Symbol">=</a><a name="9100"> </a><a name="9101" href="#9097" class="Bound">v</a><a name="9102">
</a><a name="9103" href="#8967" class="Function">permActFin</a><a name="9113"> </a><a name="9114" class="Symbol">((</a><a name="9116" href="#9116" class="Bound">a</a><a name="9117"> </a><a name="9118" class="InductiveConstructor Operator">,</a><a name="9119"> </a><a name="9120" href="#9120" class="Bound">b</a><a name="9121" class="Symbol">)</a><a name="9122"> </a><a name="9123" class="InductiveConstructor Operator">::</a><a name="9125"> </a><a name="9126" href="#9126" class="Bound">as</a><a name="9128" class="Symbol">)</a><a name="9129"> </a><a name="9130" href="#9130" class="Bound">v</a><a name="9131"> </a><a name="9132" class="Symbol">=</a><a name="9133"> </a><a name="9134" href="#8967" class="Function">permActFin</a><a name="9144"> </a><a name="9145" href="#9126" class="Bound">as</a><a name="9147"> </a><a name="9148" class="Symbol">(</a><a name="9149" href="#8515" class="Function">swapVecFin</a><a name="9159"> </a><a name="9160" href="#9116" class="Bound">a</a><a name="9161"> </a><a name="9162" href="#9120" class="Bound">b</a><a name="9163"> </a><a name="9164" href="#9130" class="Bound">v</a><a name="9165" class="Symbol">)</a><a name="9166">

</a><a name="9168" class="Keyword">data</a><a name="9172"> </a><a name="9173" href="#9173" class="Datatype">labelSwapEq</a><a name="9184"> </a><a name="9185" class="Symbol">:</a><a name="9186"> </a><a name="9187" class="Symbol">{</a><a name="9188" href="#9188" class="Bound">v</a><a name="9189"> </a><a name="9190" href="#9190" class="Bound">e</a><a name="9191"> </a><a name="9192" class="Symbol">:</a><a name="9193"> </a><a name="9194" class="Datatype">ℕ</a><a name="9195" class="Symbol">}</a><a name="9196"> </a><a name="9197" class="Symbol">→</a><a name="9198"> </a><a name="9199" class="Function">Rel</a><a name="9202"> </a><a name="9203" class="Symbol">(</a><a name="9204" class="Datatype">Vec</a><a name="9207"> </a><a name="9208" class="Symbol">((</a><a name="9210" href="#6830" class="Datatype">Fin</a><a name="9213"> </a><a name="9214" href="#9188" class="Bound">v</a><a name="9215" class="Symbol">)</a><a name="9216"> </a><a name="9217" class="Function Operator">×</a><a name="9218"> </a><a name="9219" class="Symbol">(</a><a name="9220" href="#6830" class="Datatype">Fin</a><a name="9223"> </a><a name="9224" href="#9188" class="Bound">v</a><a name="9225" class="Symbol">))</a><a name="9227"> </a><a name="9228" href="#9190" class="Bound">e</a><a name="9229" class="Symbol">)</a><a name="9230"> </a><a name="9231" class="Keyword">where</a><a name="9236">
  </a><a name="9239" href="#9239" class="InductiveConstructor">lSwapEq</a><a name="9246">  </a><a name="9248" class="Symbol">:</a><a name="9249"> </a><a name="9250" class="Symbol">{</a><a name="9251" href="#9251" class="Bound">v</a><a name="9252"> </a><a name="9253" href="#9253" class="Bound">e</a><a name="9254"> </a><a name="9255" class="Symbol">:</a><a name="9256"> </a><a name="9257" class="Datatype">ℕ</a><a name="9258" class="Symbol">}</a><a name="9259"> </a><a name="9260" class="Symbol">{</a><a name="9261" href="#9261" class="Bound">g</a><a name="9262"> </a><a name="9263" class="Symbol">:</a><a name="9264"> </a><a name="9265" class="Datatype">Vec</a><a name="9268"> </a><a name="9269" class="Symbol">((</a><a name="9271" href="#6830" class="Datatype">Fin</a><a name="9274"> </a><a name="9275" href="#9251" class="Bound">v</a><a name="9276" class="Symbol">)</a><a name="9277"> </a><a name="9278" class="Function Operator">×</a><a name="9279"> </a><a name="9280" class="Symbol">(</a><a name="9281" href="#6830" class="Datatype">Fin</a><a name="9284"> </a><a name="9285" href="#9251" class="Bound">v</a><a name="9286" class="Symbol">))</a><a name="9288"> </a><a name="9289" href="#9253" class="Bound">e</a><a name="9290" class="Symbol">}</a><a name="9291"> </a><a name="9292" class="Symbol">→</a><a name="9293"> </a><a name="9294" class="Symbol">(</a><a name="9295" href="#9295" class="Bound">a</a><a name="9296"> </a><a name="9297" href="#9297" class="Bound">b</a><a name="9298"> </a><a name="9299" class="Symbol">:</a><a name="9300"> </a><a name="9301" class="Datatype">Atom</a><a name="9305" class="Symbol">)</a><a name="9306">
             </a><a name="9320" class="Symbol">→</a><a name="9321"> </a><a name="9322" href="#9173" class="Datatype">labelSwapEq</a><a name="9333"> </a><a name="9334" class="Symbol">(</a><a name="9335" href="#8515" class="Function">swapVecFin</a><a name="9345"> </a><a name="9346" href="#9295" class="Bound">a</a><a name="9347"> </a><a name="9348" href="#9297" class="Bound">b</a><a name="9349"> </a><a name="9350" href="#9261" class="Bound">g</a><a name="9351" class="Symbol">)</a><a name="9352"> </a><a name="9353" href="#9261" class="Bound">g</a><a name="9354">
  </a><a name="9357" href="#9357" class="InductiveConstructor">lReflEq</a><a name="9364">  </a><a name="9366" class="Symbol">:</a><a name="9367"> </a><a name="9368" class="Symbol">{</a><a name="9369" href="#9369" class="Bound">v</a><a name="9370"> </a><a name="9371" href="#9371" class="Bound">e</a><a name="9372"> </a><a name="9373" class="Symbol">:</a><a name="9374"> </a><a name="9375" class="Datatype">ℕ</a><a name="9376" class="Symbol">}</a><a name="9377"> </a><a name="9378" class="Symbol">{</a><a name="9379" href="#9379" class="Bound">g</a><a name="9380"> </a><a name="9381" class="Symbol">:</a><a name="9382"> </a><a name="9383" class="Datatype">Vec</a><a name="9386"> </a><a name="9387" class="Symbol">((</a><a name="9389" href="#6830" class="Datatype">Fin</a><a name="9392"> </a><a name="9393" href="#9369" class="Bound">v</a><a name="9394" class="Symbol">)</a><a name="9395"> </a><a name="9396" class="Function Operator">×</a><a name="9397"> </a><a name="9398" class="Symbol">(</a><a name="9399" href="#6830" class="Datatype">Fin</a><a name="9402"> </a><a name="9403" href="#9369" class="Bound">v</a><a name="9404" class="Symbol">))</a><a name="9406"> </a><a name="9407" href="#9371" class="Bound">e</a><a name="9408" class="Symbol">}</a><a name="9409"> </a><a name="9410" class="Symbol">→</a><a name="9411"> </a><a name="9412" href="#9173" class="Datatype">labelSwapEq</a><a name="9423"> </a><a name="9424" href="#9379" class="Bound">g</a><a name="9425"> </a><a name="9426" href="#9379" class="Bound">g</a><a name="9427">
  </a><a name="9430" href="#9430" class="InductiveConstructor">lSymmEq</a><a name="9437">  </a><a name="9439" class="Symbol">:</a><a name="9440"> </a><a name="9441" class="Symbol">{</a><a name="9442" href="#9442" class="Bound">v</a><a name="9443"> </a><a name="9444" href="#9444" class="Bound">e</a><a name="9445"> </a><a name="9446" class="Symbol">:</a><a name="9447"> </a><a name="9448" class="Datatype">ℕ</a><a name="9449" class="Symbol">}</a><a name="9450"> </a><a name="9451" class="Symbol">{</a><a name="9452" href="#9452" class="Bound">g1</a><a name="9454"> </a><a name="9455" href="#9455" class="Bound">g2</a><a name="9457"> </a><a name="9458" class="Symbol">:</a><a name="9459"> </a><a name="9460" class="Datatype">Vec</a><a name="9463"> </a><a name="9464" class="Symbol">((</a><a name="9466" href="#6830" class="Datatype">Fin</a><a name="9469"> </a><a name="9470" href="#9442" class="Bound">v</a><a name="9471" class="Symbol">)</a><a name="9472"> </a><a name="9473" class="Function Operator">×</a><a name="9474"> </a><a name="9475" class="Symbol">(</a><a name="9476" href="#6830" class="Datatype">Fin</a><a name="9479"> </a><a name="9480" href="#9442" class="Bound">v</a><a name="9481" class="Symbol">))</a><a name="9483"> </a><a name="9484" href="#9444" class="Bound">e</a><a name="9485" class="Symbol">}</a><a name="9486"> </a><a name="9487" class="Symbol">→</a><a name="9488"> </a><a name="9489" href="#9173" class="Datatype">labelSwapEq</a><a name="9500"> </a><a name="9501" href="#9452" class="Bound">g1</a><a name="9503"> </a><a name="9504" href="#9455" class="Bound">g2</a><a name="9506">
             </a><a name="9520" class="Symbol">→</a><a name="9521"> </a><a name="9522" href="#9173" class="Datatype">labelSwapEq</a><a name="9533"> </a><a name="9534" href="#9455" class="Bound">g2</a><a name="9536"> </a><a name="9537" href="#9452" class="Bound">g1</a><a name="9539">
  </a><a name="9542" href="#9542" class="InductiveConstructor">lTransEq</a><a name="9550"> </a><a name="9551" class="Symbol">:</a><a name="9552"> </a><a name="9553" class="Symbol">{</a><a name="9554" href="#9554" class="Bound">v</a><a name="9555"> </a><a name="9556" href="#9556" class="Bound">e</a><a name="9557"> </a><a name="9558" class="Symbol">:</a><a name="9559"> </a><a name="9560" class="Datatype">ℕ</a><a name="9561" class="Symbol">}</a><a name="9562"> </a><a name="9563" class="Symbol">{</a><a name="9564" href="#9564" class="Bound">g1</a><a name="9566"> </a><a name="9567" href="#9567" class="Bound">g2</a><a name="9569"> </a><a name="9570" href="#9570" class="Bound">g3</a><a name="9572"> </a><a name="9573" class="Symbol">:</a><a name="9574"> </a><a name="9575" class="Datatype">Vec</a><a name="9578"> </a><a name="9579" class="Symbol">((</a><a name="9581" href="#6830" class="Datatype">Fin</a><a name="9584"> </a><a name="9585" href="#9554" class="Bound">v</a><a name="9586" class="Symbol">)</a><a name="9587"> </a><a name="9588" class="Function Operator">×</a><a name="9589"> </a><a name="9590" class="Symbol">(</a><a name="9591" href="#6830" class="Datatype">Fin</a><a name="9594"> </a><a name="9595" href="#9554" class="Bound">v</a><a name="9596" class="Symbol">))</a><a name="9598"> </a><a name="9599" href="#9556" class="Bound">e</a><a name="9600" class="Symbol">}</a><a name="9601"> </a><a name="9602" class="Symbol">→</a><a name="9603"> </a><a name="9604" href="#9173" class="Datatype">labelSwapEq</a><a name="9615"> </a><a name="9616" href="#9564" class="Bound">g1</a><a name="9618"> </a><a name="9619" href="#9567" class="Bound">g2</a><a name="9621">
             </a><a name="9635" class="Symbol">→</a><a name="9636"> </a><a name="9637" href="#9173" class="Datatype">labelSwapEq</a><a name="9648"> </a><a name="9649" href="#9567" class="Bound">g2</a><a name="9651"> </a><a name="9652" href="#9570" class="Bound">g3</a><a name="9654"> </a><a name="9655" class="Symbol">→</a><a name="9656"> </a><a name="9657" href="#9173" class="Datatype">labelSwapEq</a><a name="9668"> </a><a name="9669" href="#9564" class="Bound">g1</a><a name="9671"> </a><a name="9672" href="#9570" class="Bound">g3</a><a name="9674">

</a><a name="9676" href="#9676" class="Function">multiGraph₂</a><a name="9687"> </a><a name="9688" class="Symbol">:</a><a name="9689"> </a><a name="9690" class="Datatype">ℕ</a><a name="9691"> </a><a name="9692" class="Symbol">→</a><a name="9693"> </a><a name="9694" class="Datatype">ℕ</a><a name="9695"> </a><a name="9696" class="Symbol">→</a><a name="9697"> </a><a name="9698" href="#2014" class="Record">coNominal</a><a name="9707">
</a><a name="9708" href="#9676" class="Function">multiGraph₂</a><a name="9719"> </a><a name="9720" href="#9720" class="Bound">v</a><a name="9721"> </a><a name="9722" href="#9722" class="Bound">e</a><a name="9723"> </a><a name="9724" class="Symbol">=</a><a name="9725"> </a><a name="9726" class="Keyword">record</a><a name="9732"> </a><a name="9733" class="Symbol">{</a><a name="9734"> </a><a name="9735" class="Field">Aˢ</a><a name="9737"> </a><a name="9738" class="Symbol">=</a><a name="9739"> </a><a name="9740" class="Datatype">Vec</a><a name="9743"> </a><a name="9744" class="Symbol">((</a><a name="9746" href="#6830" class="Datatype">Fin</a><a name="9749"> </a><a name="9750" href="#9720" class="Bound">v</a><a name="9751" class="Symbol">)</a><a name="9752"> </a><a name="9753" class="Function Operator">×</a><a name="9754"> </a><a name="9755" class="Symbol">(</a><a name="9756" href="#6830" class="Datatype">Fin</a><a name="9759"> </a><a name="9760" href="#9720" class="Bound">v</a><a name="9761" class="Symbol">))</a><a name="9763"> </a><a name="9764" href="#9722" class="Bound">e</a><a name="9765">
                         </a><a name="9791" class="Symbol">;</a><a name="9792"> </a><a name="9793" class="Field">≈ᵃ</a><a name="9795"> </a><a name="9796" class="Symbol">=</a><a name="9797"> </a><a name="9798" href="#9173" class="Datatype">labelSwapEq</a><a name="9809">
                         </a><a name="9835" class="Symbol">;</a><a name="9836"> </a><a name="9837" class="Field">eq≈ᵃ</a><a name="9841"> </a><a name="9842" class="Symbol">=</a><a name="9843"> </a><a name="9844" class="Keyword">record</a><a name="9850"> </a><a name="9851" class="Symbol">{</a><a name="9852"> </a><a name="9853" class="Field">Reflex</a><a name="9859"> </a><a name="9860" class="Symbol">=</a><a name="9861"> </a><a name="9862" href="#9357" class="InductiveConstructor">lReflEq</a><a name="9869">
                                         </a><a name="9911" class="Symbol">;</a><a name="9912"> </a><a name="9913" class="Field">Symm</a><a name="9917"> </a><a name="9918" class="Symbol">=</a><a name="9919"> </a><a name="9920" href="#9430" class="InductiveConstructor">lSymmEq</a><a name="9927">
                                         </a><a name="9969" class="Symbol">;</a><a name="9970"> </a><a name="9971" class="Field">Trans</a><a name="9976"> </a><a name="9977" class="Symbol">=</a><a name="9978"> </a><a name="9979" href="#9542" class="InductiveConstructor">lTransEq</a><a name="9987"> </a><a name="9988" class="Symbol">}</a><a name="9989">
                         </a><a name="10015" class="Symbol">;</a><a name="10016"> </a><a name="10017" class="Field">coAct</a><a name="10022"> </a><a name="10023" class="Symbol">=</a><a name="10024"> </a><a name="10025" href="#8967" class="Function">permActFin</a><a name="10035">
                         </a><a name="10061" class="Symbol">;</a><a name="10062"> </a><a name="10063" class="Field">coRes</a><a name="10068"> </a><a name="10069" class="Symbol">=</a><a name="10070"> </a><a name="10071" class="Symbol">{!!}</a><a name="10075"> </a><a name="10076" class="Comment">-- annoying to prove, but definitely true</a><a name="10117">
                         </a><a name="10143" class="Symbol">;</a><a name="10144"> </a><a name="10145" class="Field">cop₁p₂↠</a><a name="10152"> </a><a name="10153" class="Symbol">=</a><a name="10154"> </a><a name="10155" class="Symbol">{!!}</a><a name="10159"> </a><a name="10160" class="Comment">-- annoying to prove, but definitely true</a><a name="10201">
                         </a><a name="10227" class="Symbol">;</a><a name="10228"> </a><a name="10229" class="Field">coι↠</a><a name="10233"> </a><a name="10234" class="Symbol">=</a><a name="10235"> </a><a name="10236" href="#9357" class="InductiveConstructor">lReflEq</a><a name="10243">

                         </a><a name="10270" class="Symbol">;</a><a name="10271"> </a><a name="10272" class="Field">coSupp</a><a name="10278"> </a><a name="10279" class="Symbol">=</a><a name="10280"> </a><a name="10281" class="Symbol">λ</a><a name="10282"> </a><a name="10283" href="#10283" class="Bound">_</a><a name="10284"> </a><a name="10285" class="Symbol">→</a><a name="10286"> </a><a name="10287" href="#7392" class="Function">coSuppFin</a><a name="10296"> </a><a name="10297" href="#9720" class="Bound">v</a><a name="10298">
                         </a><a name="10324" class="Symbol">;</a><a name="10325"> </a><a name="10326" class="Field">coSuppAx</a><a name="10334"> </a><a name="10335" class="Symbol">=</a><a name="10336"> </a><a name="10337" class="Symbol">λ</a><a name="10338"> </a><a name="10339" href="#10339" class="Bound">a</a><a name="10340"> </a><a name="10341" href="#10341" class="Bound">b</a><a name="10342"> </a><a name="10343" href="#10343" class="Bound">c</a><a name="10344"> </a><a name="10345" href="#10345" class="Bound">_</a><a name="10346"> </a><a name="10347" href="#10347" class="Bound">_</a><a name="10348"> </a><a name="10349" class="Symbol">→</a><a name="10350"> </a><a name="10351" href="#9239" class="InductiveConstructor">lSwapEq</a><a name="10358"> </a><a name="10359" href="#10341" class="Bound">b</a><a name="10360"> </a><a name="10361" href="#10343" class="Bound">c</a><a name="10362"> </a><a name="10363" class="Symbol">}</a></code></pre>
<p>Here, <code>multiGraph₂</code> is a coNominal set representing multigraphs, like before indexed by the number of nodes and edges; however, instead of equating all permutations of the edge set, all relabelings of the nodes of the graphs are equivalent. As there is no type constructor for coNominal sets in Agda, the sets we have defines are just terms. Thus, for the sake of simplicity of implimentation here, <code>multiGraph₂</code> is only defined over the type <code>Vec ((Fin v) × (Fin v)) e</code> (as opposed to ideally being defined over <code>multiGraph₁</code>). While we could do a deeper imbedding of the theory to allow a compositional structure for defining coNominal sets, it’d require a lot more work and would hardly be any more informative.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Choudhury, P. (2015). <a href="http://www.cl.cam.ac.uk/~amp12/agda/choudhury/choudhury-dissertation.pdf">Constructive Representation of Nominal Sets in Agda</a> (MPhil Thesis, University of Cambridge).<a href="#fnref1">↩</a></p></li>
</ol>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
