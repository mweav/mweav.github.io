<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Nominalish — Nominalish Graphs</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/agda.css" />
</head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Nominalish</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Nominalish Graphs</h1>

            <div class="post">
    Posted on September 12, 2015
    
        by Matthew Weaver
    
</div>

<p><em>…unfinished draft…</em></p>
<p>Graphs are a difficult data structure to represent in a natural and usable way. In particular, deriving a definition such that its equality matches that of graph equality is quite challenging on its own, let alone a definition that additionally permits induction over the number of vertices and edges. However, assume there is a type for (finite) sets that allows for induction over their size. Then, given some (finite) set <code>V</code>, a (finite) graph over the set <code>V</code> can be defined as the set <code>V × E</code>, where <code>E ⊆ V × V</code>. This both matches the formulation used in mathematics, and would have the desired properties described previously. Thus, we conclude with the following question: “How does one define such a formulation of sets?”</p>
<!--more-->
<p>Before getting to finite sets, let’s first consider multisets. Intuitively, a multises is the quotient of a list that “forgets” the order of its elements. In other words, all permuatations of the list are considered equal. Immedietly, the use of the term “permutation” elicits a potential connection to nominal sets, so let’s see if we can draw it explicitly.</p>
<pre class="Agda"><code><a name="1208"></a><a name="1223" class="Keyword">module</a><a name="1229"> </a><a name="1230" href="#1" class="Module">graphs</a><a name="1236"> </a><a name="1237" class="Keyword">where</a></code></pre>
<p>I am building my code off of Pritam Choudhury’s <a href="http://www.cl.cam.ac.uk/~amp12/agda/choudhury/html/README.html">Agda library</a> for nominal sets.<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<pre class="Agda"><code><a name="1621"></a><a name="1637" class="Keyword">open</a><a name="1641"> </a><a name="1642" class="Keyword">import</a><a name="1648"> </a><a name="1649" class="Module">Nominal</a></code></pre>
<p>First, in order to encode multisets, I define what I call “coNominal Sets.” Instead of being finitely supported, they are finitely cosupported; in other words, there are only finitely many atoms that can be included in swaps.</p>
<pre class="Agda"><code><a name="1894"></a><a name="1909" class="Keyword">data</a><a name="1913"> </a><a name="1914" href="#1914" class="Datatype Operator">_∈_</a><a name="1917"> </a><a name="1918" class="Symbol">(</a><a name="1919" href="#1919" class="Bound">a</a><a name="1920"> </a><a name="1921" class="Symbol">:</a><a name="1922"> </a><a name="1923" class="Datatype">Atom</a><a name="1927" class="Symbol">)</a><a name="1928"> </a><a name="1929" class="Symbol">:</a><a name="1930"> </a><a name="1931" class="Datatype">List</a><a name="1935"> </a><a name="1936" class="Datatype">Atom</a><a name="1940"> </a><a name="1941" class="Symbol">→</a><a name="1942"> </a><a name="1943" class="PrimitiveType">Set</a><a name="1946"> </a><a name="1947" class="Keyword">where</a><a name="1952">
  </a><a name="1955" href="#1955" class="InductiveConstructor">a∈a::l</a><a name="1961"> </a><a name="1962" class="Symbol">:</a><a name="1963"> </a><a name="1964" class="Symbol">∀</a><a name="1965"> </a><a name="1966" class="Symbol">{</a><a name="1967" href="#1967" class="Bound">as</a><a name="1969" class="Symbol">}</a><a name="1970"> </a><a name="1971" class="Symbol">→</a><a name="1972"> </a><a name="1973" href="#1919" class="Bound">a</a><a name="1974"> </a><a name="1975" href="#1914" class="Datatype Operator">∈</a><a name="1976"> </a><a name="1977" class="Symbol">(</a><a name="1978" href="#1919" class="Bound">a</a><a name="1979"> </a><a name="1980" class="InductiveConstructor Operator">::</a><a name="1982"> </a><a name="1983" href="#1967" class="Bound">as</a><a name="1985" class="Symbol">)</a><a name="1986">
  </a><a name="1989" href="#1989" class="InductiveConstructor">a∈as</a><a name="1993">   </a><a name="1996" class="Symbol">:</a><a name="1997"> </a><a name="1998" class="Symbol">∀</a><a name="1999"> </a><a name="2000" class="Symbol">{</a><a name="2001" href="#2001" class="Bound">b</a><a name="2002"> </a><a name="2003" href="#2003" class="Bound">as</a><a name="2005" class="Symbol">}</a><a name="2006"> </a><a name="2007" class="Symbol">→</a><a name="2008"> </a><a name="2009" href="#1919" class="Bound">a</a><a name="2010"> </a><a name="2011" href="#1914" class="Datatype Operator">∈</a><a name="2012"> </a><a name="2013" href="#2003" class="Bound">as</a><a name="2015"> </a><a name="2016" class="Symbol">→</a><a name="2017"> </a><a name="2018" href="#1919" class="Bound">a</a><a name="2019"> </a><a name="2020" href="#1914" class="Datatype Operator">∈</a><a name="2021"> </a><a name="2022" class="Symbol">(</a><a name="2023" href="#2001" class="Bound">b</a><a name="2024"> </a><a name="2025" class="InductiveConstructor Operator">::</a><a name="2027"> </a><a name="2028" href="#2003" class="Bound">as</a><a name="2030" class="Symbol">)</a><a name="2031">

</a><a name="2033" class="Keyword">record</a><a name="2039"> </a><a name="2040" href="#2040" class="Record">coNominal</a><a name="2049"> </a><a name="2050" class="Symbol">:</a><a name="2051"> </a><a name="2052" class="PrimitiveType">Set₁</a><a name="2056"> </a><a name="2057" class="Keyword">where</a><a name="2062">
  </a><a name="2065" class="Keyword">field</a><a name="2070"> 
    </a><a name="2076" href="#2076" class="Field">Aˢ</a><a name="2078"> </a><a name="2079" class="Symbol">:</a><a name="2080"> </a><a name="2081" class="PrimitiveType">Set</a><a name="2084">
    </a><a name="2089" href="#2089" class="Field">≈ᵃ</a><a name="2091"> </a><a name="2092" class="Symbol">:</a><a name="2093"> </a><a name="2094" class="Function">Rel</a><a name="2097"> </a><a name="2098" href="#2076" class="Bound">Aˢ</a><a name="2100">
    </a><a name="2105" href="#2105" class="Field">eq≈ᵃ</a><a name="2109"> </a><a name="2110" class="Symbol">:</a><a name="2111"> </a><a name="2112" class="Record">isEquivalence</a><a name="2125"> </a><a name="2126" href="#2076" class="Bound">Aˢ</a><a name="2128"> </a><a name="2129" href="#2089" class="Bound">≈ᵃ</a><a name="2131">
    </a><a name="2136" href="#2136" class="Field">coAct</a><a name="2141"> </a><a name="2142" class="Symbol">:</a><a name="2143"> </a><a name="2144" class="Function">Perm</a><a name="2148"> </a><a name="2149" class="Symbol">→</a><a name="2150"> </a><a name="2151" href="#2076" class="Bound">Aˢ</a><a name="2153"> </a><a name="2154" class="Symbol">→</a><a name="2155"> </a><a name="2156" href="#2076" class="Bound">Aˢ</a><a name="2158">
    </a><a name="2163" href="#2163" class="Field">coRes</a><a name="2168"> </a><a name="2169" class="Symbol">:</a><a name="2170"> </a><a name="2171" href="#2136" class="Bound">coAct</a><a name="2176"> </a><a name="2177" class="Function Operator">Preserves₂</a><a name="2187"> </a><a name="2188" class="Function">pEquiv</a><a name="2194"> </a><a name="2195" class="Function Operator">⟶</a><a name="2196"> </a><a name="2197" href="#2089" class="Bound">≈ᵃ</a><a name="2199"> </a><a name="2200" class="Function Operator">⟶</a><a name="2201"> </a><a name="2202" href="#2089" class="Bound">≈ᵃ</a><a name="2204">
    </a><a name="2209" href="#2209" class="Field">cop₁p₂↠</a><a name="2216"> </a><a name="2217" class="Symbol">:</a><a name="2218"> </a><a name="2219" class="Function">p₁p₂Act</a><a name="2226"> </a><a name="2227" class="Symbol">{</a><a name="2228" class="Function">Perm</a><a name="2232" class="Symbol">}{</a><a name="2234" href="#2076" class="Bound">Aˢ</a><a name="2236" class="Symbol">}{</a><a name="2238" class="Function Operator">_++_</a><a name="2242" class="Symbol">}{</a><a name="2244" href="#2089" class="Bound">≈ᵃ</a><a name="2246" class="Symbol">}{</a><a name="2248" href="#2136" class="Bound">coAct</a><a name="2253" class="Symbol">}</a><a name="2254">
    </a><a name="2259" href="#2259" class="Field">coι↠</a><a name="2263"> </a><a name="2264" class="Symbol">:</a><a name="2265"> </a><a name="2266" class="Function">ιAct</a><a name="2270"> </a><a name="2271" class="Symbol">{</a><a name="2272" class="Function">Perm</a><a name="2276" class="Symbol">}{</a><a name="2278" href="#2076" class="Bound">Aˢ</a><a name="2280" class="Symbol">}{</a><a name="2282" href="#2089" class="Bound">≈ᵃ</a><a name="2284" class="Symbol">}{</a><a name="2286" href="#2136" class="Bound">coAct</a><a name="2291" class="Symbol">}</a><a name="2292"> </a><a name="2293" class="Function">ι</a><a name="2294">

    </a><a name="2300" href="#2300" class="Field">coSupp</a><a name="2306"> </a><a name="2307" class="Symbol">:</a><a name="2308"> </a><a name="2309" href="#2076" class="Bound">Aˢ</a><a name="2311"> </a><a name="2312" class="Symbol">→</a><a name="2313"> </a><a name="2314" class="Datatype">List</a><a name="2318"> </a><a name="2319" class="Datatype">Atom</a><a name="2323">
    </a><a name="2328" href="#2328" class="Field">coSuppAx</a><a name="2336"> </a><a name="2337" class="Symbol">:</a><a name="2338"> </a><a name="2339" class="Symbol">(</a><a name="2340" href="#2340" class="Bound">a</a><a name="2341"> </a><a name="2342" class="Symbol">:</a><a name="2343"> </a><a name="2344" href="#2076" class="Bound">Aˢ</a><a name="2346" class="Symbol">)</a><a name="2347"> </a><a name="2348" class="Symbol">→</a><a name="2349"> </a><a name="2350" class="Symbol">(</a><a name="2351" href="#2351" class="Bound">b</a><a name="2352"> </a><a name="2353" href="#2353" class="Bound">c</a><a name="2354"> </a><a name="2355" class="Symbol">:</a><a name="2356"> </a><a name="2357" class="Datatype">Atom</a><a name="2361" class="Symbol">)</a><a name="2362"> </a><a name="2363" class="Symbol">→</a><a name="2364"> </a><a name="2365" class="Symbol">(</a><a name="2366" href="#2351" class="Bound">b</a><a name="2367"> </a><a name="2368" href="#1914" class="Datatype Operator">∈</a><a name="2369"> </a><a name="2370" href="#2300" class="Bound">coSupp</a><a name="2376"> </a><a name="2377" href="#2340" class="Bound">a</a><a name="2378" class="Symbol">)</a><a name="2379"> </a><a name="2380" class="Symbol">→</a><a name="2381">
               </a><a name="2397" class="Symbol">(</a><a name="2398" href="#2353" class="Bound">c</a><a name="2399"> </a><a name="2400" href="#1914" class="Datatype Operator">∈</a><a name="2401"> </a><a name="2402" href="#2300" class="Bound">coSupp</a><a name="2408"> </a><a name="2409" href="#2340" class="Bound">a</a><a name="2410" class="Symbol">)</a><a name="2411"> </a><a name="2412" class="Symbol">→</a><a name="2413"> </a><a name="2414" href="#2089" class="Bound">≈ᵃ</a><a name="2416"> </a><a name="2417" class="Symbol">(</a><a name="2418" href="#2136" class="Bound">coAct</a><a name="2423"> </a><a name="2424" class="Function Operator">[</a><a name="2425"> </a><a name="2426" class="Symbol">(</a><a name="2427" href="#2351" class="Bound">b</a><a name="2428"> </a><a name="2429" class="InductiveConstructor Operator">,</a><a name="2430"> </a><a name="2431" href="#2353" class="Bound">c</a><a name="2432" class="Symbol">)</a><a name="2433"> </a><a name="2434" class="Function Operator">]</a><a name="2435"> </a><a name="2436" href="#2340" class="Bound">a</a><a name="2437" class="Symbol">)</a><a name="2438">  </a><a name="2440" href="#2340" class="Bound">a</a><a name="2441">

</a><a name="2443" class="Keyword">open</a><a name="2447"> </a><a name="2448" href="#2040" class="Module">coNominal</a><a name="2457"> </a><a name="2458" class="Keyword">public</a></code></pre>
<p>…and then a bunch of uninteresting but necessary definitions…</p>
<pre class="Agda"><code><a name="2543"></a><a name="2558" class="Keyword">data</a><a name="2562"> </a><a name="2563" href="#2563" class="Datatype Operator">_≤_</a><a name="2566"> </a><a name="2567" class="Symbol">:</a><a name="2568"> </a><a name="2569" class="Datatype">ℕ</a><a name="2570"> </a><a name="2571" class="Symbol">→</a><a name="2572"> </a><a name="2573" class="Datatype">ℕ</a><a name="2574"> </a><a name="2575" class="Symbol">→</a><a name="2576"> </a><a name="2577" class="PrimitiveType">Set</a><a name="2580"> </a><a name="2581" class="Keyword">where</a><a name="2586">
  </a><a name="2589" href="#2589" class="InductiveConstructor">0≤n</a><a name="2592">   </a><a name="2595" class="Symbol">:</a><a name="2596"> </a><a name="2597" class="Symbol">{</a><a name="2598" href="#2598" class="Bound">n</a><a name="2599"> </a><a name="2600" class="Symbol">:</a><a name="2601"> </a><a name="2602" class="Datatype">ℕ</a><a name="2603" class="Symbol">}</a><a name="2604"> </a><a name="2605" class="Symbol">→</a><a name="2606"> </a><a name="2607" class="InductiveConstructor">zero</a><a name="2611"> </a><a name="2612" href="#2563" class="Datatype Operator">≤</a><a name="2613"> </a><a name="2614" href="#2598" class="Bound">n</a><a name="2615">
  </a><a name="2618" href="#2618" class="InductiveConstructor">≤succ</a><a name="2623"> </a><a name="2624" class="Symbol">:</a><a name="2625"> </a><a name="2626" class="Symbol">{</a><a name="2627" href="#2627" class="Bound">m</a><a name="2628"> </a><a name="2629" href="#2629" class="Bound">n</a><a name="2630"> </a><a name="2631" class="Symbol">:</a><a name="2632"> </a><a name="2633" class="Datatype">ℕ</a><a name="2634" class="Symbol">}</a><a name="2635"> </a><a name="2636" class="Symbol">→</a><a name="2637"> </a><a name="2638" href="#2627" class="Bound">m</a><a name="2639"> </a><a name="2640" href="#2563" class="Datatype Operator">≤</a><a name="2641"> </a><a name="2642" href="#2629" class="Bound">n</a><a name="2643"> </a><a name="2644" class="Symbol">→</a><a name="2645"> </a><a name="2646" class="Symbol">(</a><a name="2647" class="InductiveConstructor">succ</a><a name="2651"> </a><a name="2652" href="#2627" class="Bound">m</a><a name="2653" class="Symbol">)</a><a name="2654"> </a><a name="2655" href="#2563" class="Datatype Operator">≤</a><a name="2656"> </a><a name="2657" class="Symbol">(</a><a name="2658" class="InductiveConstructor">succ</a><a name="2662"> </a><a name="2663" href="#2629" class="Bound">n</a><a name="2664" class="Symbol">)</a><a name="2665">

</a><a name="2667" href="#2667" class="Function">dec≤lemma</a><a name="2676"> </a><a name="2677" class="Symbol">:</a><a name="2678"> </a><a name="2679" class="Symbol">∀</a><a name="2680"> </a><a name="2681" class="Symbol">{</a><a name="2682" href="#2682" class="Bound">m</a><a name="2683"> </a><a name="2684" href="#2684" class="Bound">n</a><a name="2685" class="Symbol">}</a><a name="2686"> </a><a name="2687" class="Symbol">→</a><a name="2688"> </a><a name="2689" class="Symbol">(</a><a name="2690" class="InductiveConstructor">succ</a><a name="2694"> </a><a name="2695" href="#2682" class="Bound">m</a><a name="2696" class="Symbol">)</a><a name="2697"> </a><a name="2698" href="#2563" class="Datatype Operator">≤</a><a name="2699"> </a><a name="2700" class="Symbol">(</a><a name="2701" class="InductiveConstructor">succ</a><a name="2705"> </a><a name="2706" href="#2684" class="Bound">n</a><a name="2707" class="Symbol">)</a><a name="2708"> </a><a name="2709" class="Symbol">→</a><a name="2710"> </a><a name="2711" href="#2682" class="Bound">m</a><a name="2712"> </a><a name="2713" href="#2563" class="Datatype Operator">≤</a><a name="2714"> </a><a name="2715" href="#2684" class="Bound">n</a><a name="2716">
</a><a name="2717" href="#2667" class="Function">dec≤lemma</a><a name="2726"> </a><a name="2727" class="Symbol">{</a><a name="2728" class="InductiveConstructor">zero</a><a name="2732" class="Symbol">}</a><a name="2733"> </a><a name="2734" class="Symbol">(</a><a name="2735" href="#2618" class="InductiveConstructor">≤succ</a><a name="2740"> </a><a name="2741" href="#2741" class="Bound">x</a><a name="2742" class="Symbol">)</a><a name="2743"> </a><a name="2744" class="Symbol">=</a><a name="2745"> </a><a name="2746" href="#2741" class="Bound">x</a><a name="2747">
</a><a name="2748" href="#2667" class="Function">dec≤lemma</a><a name="2757"> </a><a name="2758" class="Symbol">{</a><a name="2759" class="InductiveConstructor">succ</a><a name="2763"> </a><a name="2764" href="#2764" class="Bound">m</a><a name="2765" class="Symbol">}</a><a name="2766"> </a><a name="2767" class="Symbol">(</a><a name="2768" href="#2618" class="InductiveConstructor">≤succ</a><a name="2773"> </a><a name="2774" href="#2774" class="Bound">x</a><a name="2775" class="Symbol">)</a><a name="2776"> </a><a name="2777" class="Symbol">=</a><a name="2778"> </a><a name="2779" href="#2774" class="Bound">x</a><a name="2780">

</a><a name="2782" href="#2782" class="Function">dec≤</a><a name="2786"> </a><a name="2787" class="Symbol">:</a><a name="2788"> </a><a name="2789" class="Symbol">(</a><a name="2790" href="#2790" class="Bound">m</a><a name="2791"> </a><a name="2792" href="#2792" class="Bound">n</a><a name="2793"> </a><a name="2794" class="Symbol">:</a><a name="2795"> </a><a name="2796" class="Datatype">ℕ</a><a name="2797" class="Symbol">)</a><a name="2798"> </a><a name="2799" class="Symbol">→</a><a name="2800"> </a><a name="2801" class="Datatype">Dec</a><a name="2804"> </a><a name="2805" class="Symbol">(</a><a name="2806" href="#2790" class="Bound">m</a><a name="2807"> </a><a name="2808" href="#2563" class="Datatype Operator">≤</a><a name="2809"> </a><a name="2810" href="#2792" class="Bound">n</a><a name="2811" class="Symbol">)</a><a name="2812">
</a><a name="2813" href="#2782" class="Function">dec≤</a><a name="2817"> </a><a name="2818" class="InductiveConstructor">zero</a><a name="2822">     </a><a name="2827" class="InductiveConstructor">zero</a><a name="2831">     </a><a name="2836" class="Symbol">=</a><a name="2837"> </a><a name="2838" class="InductiveConstructor">yes</a><a name="2841"> </a><a name="2842" href="#2589" class="InductiveConstructor">0≤n</a><a name="2845">
</a><a name="2846" href="#2782" class="Function">dec≤</a><a name="2850"> </a><a name="2851" class="InductiveConstructor">zero</a><a name="2855">     </a><a name="2860" class="Symbol">(</a><a name="2861" class="InductiveConstructor">succ</a><a name="2865"> </a><a name="2866" href="#2866" class="Bound">n</a><a name="2867" class="Symbol">)</a><a name="2868"> </a><a name="2869" class="Symbol">=</a><a name="2870"> </a><a name="2871" class="InductiveConstructor">yes</a><a name="2874"> </a><a name="2875" href="#2589" class="InductiveConstructor">0≤n</a><a name="2878">
</a><a name="2879" href="#2782" class="Function">dec≤</a><a name="2883"> </a><a name="2884" class="Symbol">(</a><a name="2885" class="InductiveConstructor">succ</a><a name="2889"> </a><a name="2890" href="#2890" class="Bound">m</a><a name="2891" class="Symbol">)</a><a name="2892"> </a><a name="2893" class="InductiveConstructor">zero</a><a name="2897">     </a><a name="2902" class="Symbol">=</a><a name="2903"> </a><a name="2904" class="InductiveConstructor">no</a><a name="2906"> </a><a name="2907" class="Symbol">(λ</a><a name="2909"> </a><a name="2910" class="Symbol">())</a><a name="2913">
</a><a name="2914" href="#2782" class="Function">dec≤</a><a name="2918"> </a><a name="2919" class="Symbol">(</a><a name="2920" class="InductiveConstructor">succ</a><a name="2924"> </a><a name="2925" href="#2925" class="Bound">m</a><a name="2926" class="Symbol">)</a><a name="2927"> </a><a name="2928" class="Symbol">(</a><a name="2929" class="InductiveConstructor">succ</a><a name="2933"> </a><a name="2934" href="#2934" class="Bound">n</a><a name="2935" class="Symbol">)</a><a name="2936"> </a><a name="2937" class="Keyword">with</a><a name="2941"> </a><a name="2942" href="#2782" class="Function">dec≤</a><a name="2946"> </a><a name="2947" href="#2925" class="Bound">m</a><a name="2948"> </a><a name="2949" href="#2934" class="Bound">n</a><a name="2950">
</a><a name="2951" href="#2782" class="Function">dec≤</a><a name="2955"> </a><a name="2956" class="Symbol">(</a><a name="2957" class="InductiveConstructor">succ</a><a name="2961"> </a><a name="2962" href="#2962" class="Bound">m</a><a name="2963" class="Symbol">)</a><a name="2964"> </a><a name="2965" class="Symbol">(</a><a name="2966" class="InductiveConstructor">succ</a><a name="2970"> </a><a name="2971" href="#2971" class="Bound">n</a><a name="2972" class="Symbol">)</a><a name="2973"> </a><a name="2974" class="Symbol">|</a><a name="2975"> </a><a name="2976" class="InductiveConstructor">yes</a><a name="2979"> </a><a name="2980" href="#2980" class="Bound">p</a><a name="2981"> </a><a name="2982" class="Symbol">=</a><a name="2983"> </a><a name="2984" class="InductiveConstructor">yes</a><a name="2987"> </a><a name="2988" class="Symbol">(</a><a name="2989" href="#2618" class="InductiveConstructor">≤succ</a><a name="2994"> </a><a name="2995" href="#2980" class="Bound">p</a><a name="2996" class="Symbol">)</a><a name="2997">
</a><a name="2998" href="#2782" class="Function">dec≤</a><a name="3002"> </a><a name="3003" class="Symbol">(</a><a name="3004" class="InductiveConstructor">succ</a><a name="3008"> </a><a name="3009" href="#3009" class="Bound">m</a><a name="3010" class="Symbol">)</a><a name="3011"> </a><a name="3012" class="Symbol">(</a><a name="3013" class="InductiveConstructor">succ</a><a name="3017"> </a><a name="3018" href="#3018" class="Bound">n</a><a name="3019" class="Symbol">)</a><a name="3020"> </a><a name="3021" class="Symbol">|</a><a name="3022"> </a><a name="3023" class="InductiveConstructor">no</a><a name="3025">  </a><a name="3027" href="#3027" class="Bound">p</a><a name="3028"> </a><a name="3029" class="Symbol">=</a><a name="3030"> </a><a name="3031" class="InductiveConstructor">no</a><a name="3033"> </a><a name="3034" class="Symbol">(λ</a><a name="3036"> </a><a name="3037" href="#3037" class="Bound">q</a><a name="3038"> </a><a name="3039" class="Symbol">→</a><a name="3040"> </a><a name="3041" href="#3027" class="Bound">p</a><a name="3042"> </a><a name="3043" class="Symbol">(</a><a name="3044" href="#2667" class="Function">dec≤lemma</a><a name="3053"> </a><a name="3054" href="#3037" class="Bound">q</a><a name="3055" class="Symbol">))</a><a name="3057">

</a><a name="3059" href="#3059" class="Function">Atoℕ</a><a name="3063"> </a><a name="3064" class="Symbol">:</a><a name="3065"> </a><a name="3066" class="Datatype">Atom</a><a name="3070"> </a><a name="3071" class="Symbol">→</a><a name="3072"> </a><a name="3073" class="Datatype">ℕ</a><a name="3074">
</a><a name="3075" href="#3059" class="Function">Atoℕ</a><a name="3079"> </a><a name="3080" class="InductiveConstructor">root</a><a name="3084">     </a><a name="3089" class="Symbol">=</a><a name="3090"> </a><a name="3091" class="InductiveConstructor">zero</a><a name="3095">
</a><a name="3096" href="#3059" class="Function">Atoℕ</a><a name="3100"> </a><a name="3101" class="Symbol">(</a><a name="3102" class="InductiveConstructor">next</a><a name="3106"> </a><a name="3107" href="#3107" class="Bound">a</a><a name="3108" class="Symbol">)</a><a name="3109"> </a><a name="3110" class="Symbol">=</a><a name="3111"> </a><a name="3112" class="InductiveConstructor">succ</a><a name="3116"> </a><a name="3117" class="Symbol">(</a><a name="3118" href="#3059" class="Function">Atoℕ</a><a name="3122"> </a><a name="3123" href="#3107" class="Bound">a</a><a name="3124" class="Symbol">)</a><a name="3125">

</a><a name="3127" href="#3127" class="Function">AtListSucc</a><a name="3137"> </a><a name="3138" class="Symbol">:</a><a name="3139"> </a><a name="3140" class="Datatype">List</a><a name="3144"> </a><a name="3145" class="Datatype">Atom</a><a name="3149"> </a><a name="3150" class="Symbol">→</a><a name="3151"> </a><a name="3152" class="Datatype">List</a><a name="3156"> </a><a name="3157" class="Datatype">Atom</a><a name="3161">
</a><a name="3162" href="#3127" class="Function">AtListSucc</a><a name="3172"> </a><a name="3173" class="InductiveConstructor">[]</a><a name="3175"> </a><a name="3176" class="Symbol">=</a><a name="3177"> </a><a name="3178" class="Function Operator">[</a><a name="3179"> </a><a name="3180" class="InductiveConstructor">root</a><a name="3184"> </a><a name="3185" class="Function Operator">]</a><a name="3186">
</a><a name="3187" href="#3127" class="Function">AtListSucc</a><a name="3197"> </a><a name="3198" class="Symbol">(</a><a name="3199" href="#3199" class="Bound">a</a><a name="3200"> </a><a name="3201" class="InductiveConstructor Operator">::</a><a name="3203"> </a><a name="3204" href="#3204" class="Bound">as</a><a name="3206" class="Symbol">)</a><a name="3207"> </a><a name="3208" class="Symbol">=</a><a name="3209"> </a><a name="3210" class="Symbol">(</a><a name="3211" class="InductiveConstructor">next</a><a name="3215"> </a><a name="3216" href="#3199" class="Bound">a</a><a name="3217" class="Symbol">)</a><a name="3218"> </a><a name="3219" class="InductiveConstructor Operator">::</a><a name="3221"> </a><a name="3222" class="Symbol">(</a><a name="3223" href="#3199" class="Bound">a</a><a name="3224"> </a><a name="3225" class="InductiveConstructor Operator">::</a><a name="3227"> </a><a name="3228" href="#3204" class="Bound">as</a><a name="3230" class="Symbol">)</a><a name="3231">

</a><a name="3233" href="#3233" class="Function">coSuppVec</a><a name="3242"> </a><a name="3243" class="Symbol">:</a><a name="3244"> </a><a name="3245" class="Symbol">{</a><a name="3246" href="#3246" class="Bound">X</a><a name="3247"> </a><a name="3248" class="Symbol">:</a><a name="3249"> </a><a name="3250" class="PrimitiveType">Set</a><a name="3253" class="Symbol">}</a><a name="3254"> </a><a name="3255" class="Symbol">{</a><a name="3256" href="#3256" class="Bound">n</a><a name="3257"> </a><a name="3258" class="Symbol">:</a><a name="3259"> </a><a name="3260" class="Datatype">ℕ</a><a name="3261" class="Symbol">}</a><a name="3262"> </a><a name="3263" class="Symbol">→</a><a name="3264"> </a><a name="3265" class="Datatype">Vec</a><a name="3268"> </a><a name="3269" href="#3246" class="Bound">X</a><a name="3270"> </a><a name="3271" href="#3256" class="Bound">n</a><a name="3272"> </a><a name="3273" class="Symbol">→</a><a name="3274"> </a><a name="3275" class="Datatype">List</a><a name="3279"> </a><a name="3280" class="Datatype">Atom</a><a name="3284">
</a><a name="3285" href="#3233" class="Function">coSuppVec</a><a name="3294"> </a><a name="3295" class="InductiveConstructor">[]</a><a name="3297"> </a><a name="3298" class="Symbol">=</a><a name="3299"> </a><a name="3300" class="InductiveConstructor">[]</a><a name="3302">
</a><a name="3303" href="#3233" class="Function">coSuppVec</a><a name="3312"> </a><a name="3313" class="Symbol">(</a><a name="3314" href="#3314" class="Bound">x</a><a name="3315"> </a><a name="3316" class="InductiveConstructor Operator">::</a><a name="3318"> </a><a name="3319" href="#3319" class="Bound">xs</a><a name="3321" class="Symbol">)</a><a name="3322"> </a><a name="3323" class="Symbol">=</a><a name="3324"> </a><a name="3325" href="#3127" class="Function">AtListSucc</a><a name="3335"> </a><a name="3336" class="Symbol">(</a><a name="3337" href="#3233" class="Function">coSuppVec</a><a name="3346"> </a><a name="3347" href="#3319" class="Bound">xs</a><a name="3349" class="Symbol">)</a></code></pre>
<p>As we are defining multisets as a coNominal set, we need to define an action of permutations on our type. As we are looking to equate all reorderings of our multiSets, we define the action to simply be the standard permuation action on lists.</p>
<pre class="Agda"><code><a name="3606"></a><a name="3621" href="#3621" class="Function">getVal</a><a name="3627"> </a><a name="3628" class="Symbol">:</a><a name="3629"> </a><a name="3630" class="Symbol">{</a><a name="3631" href="#3631" class="Bound">X</a><a name="3632"> </a><a name="3633" class="Symbol">:</a><a name="3634"> </a><a name="3635" class="PrimitiveType">Set</a><a name="3638" class="Symbol">}</a><a name="3639"> </a><a name="3640" class="Symbol">{</a><a name="3641" href="#3641" class="Bound">n</a><a name="3642"> </a><a name="3643" class="Symbol">:</a><a name="3644"> </a><a name="3645" class="Datatype">ℕ</a><a name="3646" class="Symbol">}</a><a name="3647"> </a><a name="3648" class="Symbol">→</a><a name="3649"> </a><a name="3650" class="Symbol">(</a><a name="3651" href="#3651" class="Bound">i</a><a name="3652"> </a><a name="3653" class="Symbol">:</a><a name="3654"> </a><a name="3655" class="Datatype">ℕ</a><a name="3656" class="Symbol">)</a><a name="3657"> </a><a name="3658" class="Symbol">→</a><a name="3659"> </a><a name="3660" class="Datatype">Vec</a><a name="3663"> </a><a name="3664" href="#3631" class="Bound">X</a><a name="3665"> </a><a name="3666" href="#3641" class="Bound">n</a><a name="3667"> </a><a name="3668" class="Symbol">→</a><a name="3669"> </a><a name="3670" class="Symbol">(</a><a name="3671" class="InductiveConstructor">succ</a><a name="3675"> </a><a name="3676" href="#3651" class="Bound">i</a><a name="3677" class="Symbol">)</a><a name="3678"> </a><a name="3679" href="#2563" class="Datatype Operator">≤</a><a name="3680"> </a><a name="3681" href="#3641" class="Bound">n</a><a name="3682"> </a><a name="3683" class="Symbol">→</a><a name="3684"> </a><a name="3685" href="#3631" class="Bound">X</a><a name="3686">
</a><a name="3687" href="#3621" class="Function">getVal</a><a name="3693"> </a><a name="3694" class="Symbol">{</a><a name="3695" class="Argument">n</a><a name="3696"> </a><a name="3697" class="Symbol">=</a><a name="3698"> </a><a name="3699" class="InductiveConstructor">succ</a><a name="3703"> </a><a name="3704" href="#3704" class="Bound">n</a><a name="3705" class="Symbol">}</a><a name="3706"> </a><a name="3707" class="InductiveConstructor">zero</a><a name="3711"> </a><a name="3712" class="Symbol">(</a><a name="3713" href="#3713" class="Bound">a</a><a name="3714"> </a><a name="3715" class="InductiveConstructor Operator">::</a><a name="3717"> </a><a name="3718" href="#3718" class="Bound">v</a><a name="3719" class="Symbol">)</a><a name="3720"> </a><a name="3721" class="Symbol">(</a><a name="3722" href="#2618" class="InductiveConstructor">≤succ</a><a name="3727"> </a><a name="3728" href="#3728" class="Bound">p</a><a name="3729" class="Symbol">)</a><a name="3730"> </a><a name="3731" class="Symbol">=</a><a name="3732"> </a><a name="3733" href="#3713" class="Bound">a</a><a name="3734">
</a><a name="3735" href="#3621" class="Function">getVal</a><a name="3741"> </a><a name="3742" class="Symbol">{</a><a name="3743" class="Argument">n</a><a name="3744"> </a><a name="3745" class="Symbol">=</a><a name="3746"> </a><a name="3747" class="InductiveConstructor">succ</a><a name="3751"> </a><a name="3752" href="#3752" class="Bound">n</a><a name="3753" class="Symbol">}</a><a name="3754"> </a><a name="3755" class="Symbol">(</a><a name="3756" class="InductiveConstructor">succ</a><a name="3760"> </a><a name="3761" href="#3761" class="Bound">i</a><a name="3762" class="Symbol">)</a><a name="3763"> </a><a name="3764" class="Symbol">(</a><a name="3765" href="#3765" class="Bound">a</a><a name="3766"> </a><a name="3767" class="InductiveConstructor Operator">::</a><a name="3769"> </a><a name="3770" href="#3770" class="Bound">v</a><a name="3771" class="Symbol">)</a><a name="3772"> </a><a name="3773" class="Symbol">(</a><a name="3774" href="#2618" class="InductiveConstructor">≤succ</a><a name="3779"> </a><a name="3780" href="#3780" class="Bound">p</a><a name="3781" class="Symbol">)</a><a name="3782"> </a><a name="3783" class="Symbol">=</a><a name="3784"> </a><a name="3785" href="#3621" class="Function">getVal</a><a name="3791"> </a><a name="3792" href="#3761" class="Bound">i</a><a name="3793"> </a><a name="3794" href="#3770" class="Bound">v</a><a name="3795"> </a><a name="3796" href="#3780" class="Bound">p</a><a name="3797">

</a><a name="3799" href="#3799" class="Function">replace</a><a name="3806"> </a><a name="3807" class="Symbol">:</a><a name="3808"> </a><a name="3809" class="Symbol">{</a><a name="3810" href="#3810" class="Bound">X</a><a name="3811"> </a><a name="3812" class="Symbol">:</a><a name="3813"> </a><a name="3814" class="PrimitiveType">Set</a><a name="3817" class="Symbol">}</a><a name="3818"> </a><a name="3819" class="Symbol">{</a><a name="3820" href="#3820" class="Bound">n</a><a name="3821"> </a><a name="3822" class="Symbol">:</a><a name="3823"> </a><a name="3824" class="Datatype">ℕ</a><a name="3825" class="Symbol">}</a><a name="3826"> </a><a name="3827" class="Symbol">→</a><a name="3828"> </a><a name="3829" class="Symbol">(</a><a name="3830" href="#3830" class="Bound">i</a><a name="3831"> </a><a name="3832" class="Symbol">:</a><a name="3833"> </a><a name="3834" class="Datatype">ℕ</a><a name="3835" class="Symbol">)</a><a name="3836"> </a><a name="3837" class="Symbol">→</a><a name="3838"> </a><a name="3839" href="#3810" class="Bound">X</a><a name="3840"> </a><a name="3841" class="Symbol">→</a><a name="3842"> </a><a name="3843" class="Datatype">Vec</a><a name="3846"> </a><a name="3847" href="#3810" class="Bound">X</a><a name="3848"> </a><a name="3849" href="#3820" class="Bound">n</a><a name="3850"> </a><a name="3851" class="Symbol">→</a><a name="3852"> </a><a name="3853" class="Symbol">(</a><a name="3854" class="InductiveConstructor">succ</a><a name="3858"> </a><a name="3859" href="#3830" class="Bound">i</a><a name="3860" class="Symbol">)</a><a name="3861"> </a><a name="3862" href="#2563" class="Datatype Operator">≤</a><a name="3863"> </a><a name="3864" href="#3820" class="Bound">n</a><a name="3865"> </a><a name="3866" class="Symbol">→</a><a name="3867"> </a><a name="3868" class="Datatype">Vec</a><a name="3871"> </a><a name="3872" href="#3810" class="Bound">X</a><a name="3873"> </a><a name="3874" href="#3820" class="Bound">n</a><a name="3875">
</a><a name="3876" href="#3799" class="Function">replace</a><a name="3883"> </a><a name="3884" class="Symbol">{</a><a name="3885" class="Argument">n</a><a name="3886"> </a><a name="3887" class="Symbol">=</a><a name="3888"> </a><a name="3889" class="InductiveConstructor">succ</a><a name="3893"> </a><a name="3894" href="#3894" class="Bound">n</a><a name="3895" class="Symbol">}</a><a name="3896"> </a><a name="3897" class="InductiveConstructor">zero</a><a name="3901"> </a><a name="3902" href="#3902" class="Bound">x</a><a name="3903"> </a><a name="3904" class="Symbol">(</a><a name="3905" href="#3905" class="Bound">a</a><a name="3906"> </a><a name="3907" class="InductiveConstructor Operator">::</a><a name="3909"> </a><a name="3910" href="#3910" class="Bound">v</a><a name="3911" class="Symbol">)</a><a name="3912"> </a><a name="3913" class="Symbol">(</a><a name="3914" href="#2618" class="InductiveConstructor">≤succ</a><a name="3919"> </a><a name="3920" href="#3920" class="Bound">p</a><a name="3921" class="Symbol">)</a><a name="3922"> </a><a name="3923" class="Symbol">=</a><a name="3924"> </a><a name="3925" href="#3902" class="Bound">x</a><a name="3926"> </a><a name="3927" class="InductiveConstructor Operator">::</a><a name="3929"> </a><a name="3930" href="#3910" class="Bound">v</a><a name="3931">
</a><a name="3932" href="#3799" class="Function">replace</a><a name="3939"> </a><a name="3940" class="Symbol">{</a><a name="3941" class="Argument">n</a><a name="3942"> </a><a name="3943" class="Symbol">=</a><a name="3944"> </a><a name="3945" class="InductiveConstructor">succ</a><a name="3949"> </a><a name="3950" href="#3950" class="Bound">n</a><a name="3951" class="Symbol">}</a><a name="3952"> </a><a name="3953" class="Symbol">(</a><a name="3954" class="InductiveConstructor">succ</a><a name="3958"> </a><a name="3959" href="#3959" class="Bound">i</a><a name="3960" class="Symbol">)</a><a name="3961"> </a><a name="3962" href="#3962" class="Bound">x</a><a name="3963"> </a><a name="3964" class="Symbol">(</a><a name="3965" href="#3965" class="Bound">a</a><a name="3966"> </a><a name="3967" class="InductiveConstructor Operator">::</a><a name="3969"> </a><a name="3970" href="#3970" class="Bound">v</a><a name="3971" class="Symbol">)</a><a name="3972"> </a><a name="3973" class="Symbol">(</a><a name="3974" href="#2618" class="InductiveConstructor">≤succ</a><a name="3979"> </a><a name="3980" href="#3980" class="Bound">p</a><a name="3981" class="Symbol">)</a><a name="3982"> </a><a name="3983" class="Symbol">=</a><a name="3984"> </a><a name="3985" href="#3965" class="Bound">a</a><a name="3986"> </a><a name="3987" class="InductiveConstructor Operator">::</a><a name="3989"> </a><a name="3990" class="Symbol">(</a><a name="3991" href="#3799" class="Function">replace</a><a name="3998"> </a><a name="3999" href="#3959" class="Bound">i</a><a name="4000"> </a><a name="4001" href="#3962" class="Bound">x</a><a name="4002"> </a><a name="4003" href="#3970" class="Bound">v</a><a name="4004"> </a><a name="4005" href="#3980" class="Bound">p</a><a name="4006" class="Symbol">)</a><a name="4007">

</a><a name="4009" href="#4009" class="Function">headSwap</a><a name="4017"> </a><a name="4018" class="Symbol">:</a><a name="4019"> </a><a name="4020" class="Symbol">{</a><a name="4021" href="#4021" class="Bound">X</a><a name="4022"> </a><a name="4023" class="Symbol">:</a><a name="4024"> </a><a name="4025" class="PrimitiveType">Set</a><a name="4028" class="Symbol">}</a><a name="4029"> </a><a name="4030" class="Symbol">{</a><a name="4031" href="#4031" class="Bound">n</a><a name="4032"> </a><a name="4033" class="Symbol">:</a><a name="4034"> </a><a name="4035" class="Datatype">ℕ</a><a name="4036" class="Symbol">}</a><a name="4037"> </a><a name="4038" class="Symbol">→</a><a name="4039"> </a><a name="4040" class="Symbol">(</a><a name="4041" href="#4041" class="Bound">i</a><a name="4042"> </a><a name="4043" class="Symbol">:</a><a name="4044"> </a><a name="4045" class="Datatype">ℕ</a><a name="4046" class="Symbol">)</a><a name="4047"> </a><a name="4048" class="Symbol">→</a><a name="4049"> </a><a name="4050" class="Datatype">Vec</a><a name="4053"> </a><a name="4054" href="#4021" class="Bound">X</a><a name="4055"> </a><a name="4056" href="#4031" class="Bound">n</a><a name="4057"> </a><a name="4058" class="Symbol">→</a><a name="4059"> </a><a name="4060" class="Symbol">(</a><a name="4061" class="InductiveConstructor">succ</a><a name="4065"> </a><a name="4066" href="#4041" class="Bound">i</a><a name="4067" class="Symbol">)</a><a name="4068"> </a><a name="4069" href="#2563" class="Datatype Operator">≤</a><a name="4070"> </a><a name="4071" href="#4031" class="Bound">n</a><a name="4072"> </a><a name="4073" class="Symbol">→</a><a name="4074"> </a><a name="4075" class="Datatype">Vec</a><a name="4078"> </a><a name="4079" href="#4021" class="Bound">X</a><a name="4080"> </a><a name="4081" href="#4031" class="Bound">n</a><a name="4082">
</a><a name="4083" href="#4009" class="Function">headSwap</a><a name="4091"> </a><a name="4092" class="InductiveConstructor">zero</a><a name="4096"> </a><a name="4097" class="Symbol">(</a><a name="4098" href="#4098" class="Bound">a</a><a name="4099"> </a><a name="4100" class="InductiveConstructor Operator">::</a><a name="4102"> </a><a name="4103" href="#4103" class="Bound">v</a><a name="4104" class="Symbol">)</a><a name="4105"> </a><a name="4106" class="Symbol">(</a><a name="4107" href="#2618" class="InductiveConstructor">≤succ</a><a name="4112"> </a><a name="4113" href="#4113" class="Bound">p</a><a name="4114" class="Symbol">)</a><a name="4115"> </a><a name="4116" class="Symbol">=</a><a name="4117"> </a><a name="4118" href="#4098" class="Bound">a</a><a name="4119"> </a><a name="4120" class="InductiveConstructor Operator">::</a><a name="4122"> </a><a name="4123" href="#4103" class="Bound">v</a><a name="4124">
</a><a name="4125" href="#4009" class="Function">headSwap</a><a name="4133"> </a><a name="4134" class="Symbol">(</a><a name="4135" class="InductiveConstructor">succ</a><a name="4139"> </a><a name="4140" href="#4140" class="Bound">i</a><a name="4141" class="Symbol">)</a><a name="4142"> </a><a name="4143" class="Symbol">(</a><a name="4144" href="#4144" class="Bound">a</a><a name="4145"> </a><a name="4146" class="InductiveConstructor Operator">::</a><a name="4148"> </a><a name="4149" href="#4149" class="Bound">v</a><a name="4150" class="Symbol">)</a><a name="4151"> </a><a name="4152" class="Symbol">(</a><a name="4153" href="#2618" class="InductiveConstructor">≤succ</a><a name="4158"> </a><a name="4159" href="#4159" class="Bound">p</a><a name="4160" class="Symbol">)</a><a name="4161"> </a><a name="4162" class="Symbol">=</a><a name="4163"> </a><a name="4164" class="Symbol">(</a><a name="4165" href="#3621" class="Function">getVal</a><a name="4171"> </a><a name="4172" href="#4140" class="Bound">i</a><a name="4173"> </a><a name="4174" href="#4149" class="Bound">v</a><a name="4175"> </a><a name="4176" href="#4159" class="Bound">p</a><a name="4177" class="Symbol">)</a><a name="4178"> </a><a name="4179" class="InductiveConstructor Operator">::</a><a name="4181"> </a><a name="4182" class="Symbol">(</a><a name="4183" href="#3799" class="Function">replace</a><a name="4190"> </a><a name="4191" href="#4140" class="Bound">i</a><a name="4192"> </a><a name="4193" href="#4144" class="Bound">a</a><a name="4194"> </a><a name="4195" href="#4149" class="Bound">v</a><a name="4196"> </a><a name="4197" href="#4159" class="Bound">p</a><a name="4198" class="Symbol">)</a><a name="4199">

</a><a name="4201" href="#4201" class="Function">swapVec</a><a name="4208"> </a><a name="4209" class="Symbol">:</a><a name="4210"> </a><a name="4211" class="Symbol">{</a><a name="4212" href="#4212" class="Bound">X</a><a name="4213"> </a><a name="4214" class="Symbol">:</a><a name="4215"> </a><a name="4216" class="PrimitiveType">Set</a><a name="4219" class="Symbol">}</a><a name="4220"> </a><a name="4221" class="Symbol">{</a><a name="4222" href="#4222" class="Bound">n</a><a name="4223"> </a><a name="4224" class="Symbol">:</a><a name="4225"> </a><a name="4226" class="Datatype">ℕ</a><a name="4227" class="Symbol">}</a><a name="4228"> </a><a name="4229" class="Symbol">→</a><a name="4230"> </a><a name="4231" class="Datatype">Atom</a><a name="4235"> </a><a name="4236" class="Symbol">→</a><a name="4237"> </a><a name="4238" class="Datatype">Atom</a><a name="4242"> </a><a name="4243" class="Symbol">→</a><a name="4244"> </a><a name="4245" class="Datatype">Vec</a><a name="4248"> </a><a name="4249" href="#4212" class="Bound">X</a><a name="4250"> </a><a name="4251" href="#4222" class="Bound">n</a><a name="4252"> </a><a name="4253" class="Symbol">→</a><a name="4254"> </a><a name="4255" class="Datatype">Vec</a><a name="4258"> </a><a name="4259" href="#4212" class="Bound">X</a><a name="4260"> </a><a name="4261" href="#4222" class="Bound">n</a><a name="4262">
</a><a name="4263" href="#4201" class="Function">swapVec</a><a name="4270"> </a><a name="4271" class="Symbol">{</a><a name="4272" href="#4272" class="Bound">X</a><a name="4273" class="Symbol">}</a><a name="4274"> </a><a name="4275" class="Symbol">{</a><a name="4276" href="#4276" class="Bound">n</a><a name="4277" class="Symbol">}</a><a name="4278"> </a><a name="4279" href="#4279" class="Bound">a</a><a name="4280"> </a><a name="4281" href="#4281" class="Bound">b</a><a name="4282"> </a><a name="4283" href="#4283" class="Bound">v</a><a name="4284"> </a><a name="4285" class="Keyword">with</a><a name="4289"> </a><a name="4290" href="#2782" class="Function">dec≤</a><a name="4294"> </a><a name="4295" class="Symbol">(</a><a name="4296" class="InductiveConstructor">succ</a><a name="4300"> </a><a name="4301" class="Symbol">(</a><a name="4302" href="#3059" class="Function">Atoℕ</a><a name="4306"> </a><a name="4307" href="#4279" class="Bound">a</a><a name="4308" class="Symbol">))</a><a name="4310"> </a><a name="4311" href="#4276" class="Bound">n</a><a name="4312"> </a><a name="4313" class="Symbol">|</a><a name="4314"> </a><a name="4315" href="#2782" class="Function">dec≤</a><a name="4319"> </a><a name="4320" class="Symbol">(</a><a name="4321" class="InductiveConstructor">succ</a><a name="4325"> </a><a name="4326" class="Symbol">(</a><a name="4327" href="#3059" class="Function">Atoℕ</a><a name="4331"> </a><a name="4332" href="#4281" class="Bound">b</a><a name="4333" class="Symbol">))</a><a name="4335"> </a><a name="4336" href="#4276" class="Bound">n</a><a name="4337">
</a><a name="4338" href="#4201" class="Function">swapVec</a><a name="4345"> </a><a name="4346" class="InductiveConstructor">root</a><a name="4350">     </a><a name="4355" class="InductiveConstructor">root</a><a name="4359">     </a><a name="4364" href="#4364" class="Bound">v</a><a name="4365">         </a><a name="4374" class="Symbol">|</a><a name="4375"> </a><a name="4376" class="InductiveConstructor">yes</a><a name="4379"> </a><a name="4380" href="#4380" class="Bound">p</a><a name="4381">         </a><a name="4390" class="Symbol">|</a><a name="4391"> </a><a name="4392" class="InductiveConstructor">yes</a><a name="4395"> </a><a name="4396" href="#4396" class="Bound">q</a><a name="4397">
                                    </a><a name="4434" class="Symbol">=</a><a name="4435"> </a><a name="4436" href="#4364" class="Bound">v</a><a name="4437">
</a><a name="4438" href="#4201" class="Function">swapVec</a><a name="4445"> </a><a name="4446" class="InductiveConstructor">root</a><a name="4450">     </a><a name="4455" class="Symbol">(</a><a name="4456" class="InductiveConstructor">next</a><a name="4460"> </a><a name="4461" href="#4461" class="Bound">b</a><a name="4462" class="Symbol">)</a><a name="4463"> </a><a name="4464" class="Symbol">(</a><a name="4465" href="#4465" class="Bound">x</a><a name="4466"> </a><a name="4467" class="InductiveConstructor Operator">::</a><a name="4469"> </a><a name="4470" href="#4470" class="Bound">v'</a><a name="4472" class="Symbol">)</a><a name="4473"> </a><a name="4474" class="Symbol">|</a><a name="4475"> </a><a name="4476" class="InductiveConstructor">yes</a><a name="4479"> </a><a name="4480" href="#4480" class="Bound">p</a><a name="4481">         </a><a name="4490" class="Symbol">|</a><a name="4491"> </a><a name="4492" class="InductiveConstructor">yes</a><a name="4495"> </a><a name="4496" class="Symbol">(</a><a name="4497" href="#2618" class="InductiveConstructor">≤succ</a><a name="4502"> </a><a name="4503" href="#4503" class="Bound">q</a><a name="4504" class="Symbol">)</a><a name="4505">
                                    </a><a name="4542" class="Symbol">=</a><a name="4543"> </a><a name="4544" href="#4009" class="Function">headSwap</a><a name="4552"> </a><a name="4553" class="Symbol">(</a><a name="4554" href="#3059" class="Function">Atoℕ</a><a name="4558"> </a><a name="4559" class="Symbol">(</a><a name="4560" class="InductiveConstructor">next</a><a name="4564"> </a><a name="4565" href="#4461" class="Bound">b</a><a name="4566" class="Symbol">))</a><a name="4568"> </a><a name="4569" class="Symbol">(</a><a name="4570" href="#4465" class="Bound">x</a><a name="4571"> </a><a name="4572" class="InductiveConstructor Operator">::</a><a name="4574"> </a><a name="4575" href="#4470" class="Bound">v'</a><a name="4577" class="Symbol">)</a><a name="4578"> </a><a name="4579" class="Symbol">(</a><a name="4580" href="#2618" class="InductiveConstructor">≤succ</a><a name="4585"> </a><a name="4586" href="#4503" class="Bound">q</a><a name="4587" class="Symbol">)</a><a name="4588">
</a><a name="4589" href="#4201" class="Function">swapVec</a><a name="4596"> </a><a name="4597" class="Symbol">(</a><a name="4598" class="InductiveConstructor">next</a><a name="4602"> </a><a name="4603" href="#4603" class="Bound">a</a><a name="4604" class="Symbol">)</a><a name="4605"> </a><a name="4606" class="InductiveConstructor">root</a><a name="4610">     </a><a name="4615" class="Symbol">(</a><a name="4616" href="#4616" class="Bound">x</a><a name="4617"> </a><a name="4618" class="InductiveConstructor Operator">::</a><a name="4620"> </a><a name="4621" href="#4621" class="Bound">v'</a><a name="4623" class="Symbol">)</a><a name="4624"> </a><a name="4625" class="Symbol">|</a><a name="4626"> </a><a name="4627" class="InductiveConstructor">yes</a><a name="4630"> </a><a name="4631" class="Symbol">(</a><a name="4632" href="#2618" class="InductiveConstructor">≤succ</a><a name="4637"> </a><a name="4638" href="#4638" class="Bound">p</a><a name="4639" class="Symbol">)</a><a name="4640"> </a><a name="4641" class="Symbol">|</a><a name="4642"> </a><a name="4643" class="InductiveConstructor">yes</a><a name="4646"> </a><a name="4647" href="#4647" class="Bound">q</a><a name="4648">
                                    </a><a name="4685" class="Symbol">=</a><a name="4686"> </a><a name="4687" href="#4009" class="Function">headSwap</a><a name="4695"> </a><a name="4696" class="Symbol">(</a><a name="4697" href="#3059" class="Function">Atoℕ</a><a name="4701"> </a><a name="4702" class="Symbol">(</a><a name="4703" class="InductiveConstructor">next</a><a name="4707"> </a><a name="4708" href="#4603" class="Bound">a</a><a name="4709" class="Symbol">))</a><a name="4711"> </a><a name="4712" class="Symbol">(</a><a name="4713" href="#4616" class="Bound">x</a><a name="4714"> </a><a name="4715" class="InductiveConstructor Operator">::</a><a name="4717"> </a><a name="4718" href="#4621" class="Bound">v'</a><a name="4720" class="Symbol">)</a><a name="4721"> </a><a name="4722" class="Symbol">(</a><a name="4723" href="#2618" class="InductiveConstructor">≤succ</a><a name="4728"> </a><a name="4729" href="#4638" class="Bound">p</a><a name="4730" class="Symbol">)</a><a name="4731">
</a><a name="4732" href="#4201" class="Function">swapVec</a><a name="4739"> </a><a name="4740" class="Symbol">(</a><a name="4741" class="InductiveConstructor">next</a><a name="4745"> </a><a name="4746" href="#4746" class="Bound">a</a><a name="4747" class="Symbol">)</a><a name="4748"> </a><a name="4749" class="Symbol">(</a><a name="4750" class="InductiveConstructor">next</a><a name="4754"> </a><a name="4755" href="#4755" class="Bound">b</a><a name="4756" class="Symbol">)</a><a name="4757"> </a><a name="4758" class="Symbol">(</a><a name="4759" href="#4759" class="Bound">x</a><a name="4760"> </a><a name="4761" class="InductiveConstructor Operator">::</a><a name="4763"> </a><a name="4764" href="#4764" class="Bound">v'</a><a name="4766" class="Symbol">)</a><a name="4767"> </a><a name="4768" class="Symbol">|</a><a name="4769"> </a><a name="4770" class="InductiveConstructor">yes</a><a name="4773"> </a><a name="4774" href="#4774" class="Bound">p</a><a name="4775">         </a><a name="4784" class="Symbol">|</a><a name="4785"> </a><a name="4786" class="InductiveConstructor">yes</a><a name="4789"> </a><a name="4790" href="#4790" class="Bound">q</a><a name="4791">
                                    </a><a name="4828" class="Symbol">=</a><a name="4829"> </a><a name="4830" href="#4759" class="Bound">x</a><a name="4831"> </a><a name="4832" class="InductiveConstructor Operator">::</a><a name="4834"> </a><a name="4835" class="Symbol">(</a><a name="4836" href="#4201" class="Function">swapVec</a><a name="4843"> </a><a name="4844" href="#4746" class="Bound">a</a><a name="4845"> </a><a name="4846" href="#4755" class="Bound">b</a><a name="4847"> </a><a name="4848" href="#4764" class="Bound">v'</a><a name="4850" class="Symbol">)</a><a name="4851">
</a><a name="4852" href="#4201" class="Function">swapVec</a><a name="4859"> </a><a name="4860" class="Symbol">{</a><a name="4861" href="#4861" class="Bound">X</a><a name="4862" class="Symbol">}</a><a name="4863"> </a><a name="4864" class="Symbol">{</a><a name="4865" href="#4865" class="Bound">n</a><a name="4866" class="Symbol">}</a><a name="4867"> </a><a name="4868" href="#4868" class="Bound">a</a><a name="4869"> </a><a name="4870" href="#4870" class="Bound">b</a><a name="4871"> </a><a name="4872" href="#4872" class="Bound">v</a><a name="4873"> </a><a name="4874" class="Symbol">|</a><a name="4875"> </a><a name="4876" class="Symbol">_</a><a name="4877">    </a><a name="4881" class="Symbol">|</a><a name="4882"> </a><a name="4883" class="Symbol">_</a><a name="4884">    </a><a name="4888" class="Symbol">=</a><a name="4889"> </a><a name="4890" href="#4872" class="Bound">v</a><a name="4891">

</a><a name="4893" href="#4893" class="Function">permActVec</a><a name="4903"> </a><a name="4904" class="Symbol">:</a><a name="4905"> </a><a name="4906" class="Symbol">{</a><a name="4907" href="#4907" class="Bound">X</a><a name="4908"> </a><a name="4909" class="Symbol">:</a><a name="4910"> </a><a name="4911" class="PrimitiveType">Set</a><a name="4914" class="Symbol">}</a><a name="4915"> </a><a name="4916" class="Symbol">{</a><a name="4917" href="#4917" class="Bound">n</a><a name="4918"> </a><a name="4919" class="Symbol">:</a><a name="4920"> </a><a name="4921" class="Datatype">ℕ</a><a name="4922" class="Symbol">}</a><a name="4923"> </a><a name="4924" class="Symbol">→</a><a name="4925"> </a><a name="4926" class="Function">Perm</a><a name="4930"> </a><a name="4931" class="Symbol">→</a><a name="4932"> </a><a name="4933" class="Datatype">Vec</a><a name="4936"> </a><a name="4937" href="#4907" class="Bound">X</a><a name="4938"> </a><a name="4939" href="#4917" class="Bound">n</a><a name="4940"> </a><a name="4941" class="Symbol">→</a><a name="4942"> </a><a name="4943" class="Datatype">Vec</a><a name="4946"> </a><a name="4947" href="#4907" class="Bound">X</a><a name="4948"> </a><a name="4949" href="#4917" class="Bound">n</a><a name="4950">
</a><a name="4951" href="#4893" class="Function">permActVec</a><a name="4961"> </a><a name="4962" class="InductiveConstructor">[]</a><a name="4964"> </a><a name="4965" href="#4965" class="Bound">v</a><a name="4966"> </a><a name="4967" class="Symbol">=</a><a name="4968"> </a><a name="4969" href="#4965" class="Bound">v</a><a name="4970">
</a><a name="4971" href="#4893" class="Function">permActVec</a><a name="4981"> </a><a name="4982" class="Symbol">((</a><a name="4984" href="#4984" class="Bound">a</a><a name="4985"> </a><a name="4986" class="InductiveConstructor Operator">,</a><a name="4987"> </a><a name="4988" href="#4988" class="Bound">b</a><a name="4989" class="Symbol">)</a><a name="4990"> </a><a name="4991" class="InductiveConstructor Operator">::</a><a name="4993"> </a><a name="4994" href="#4994" class="Bound">as</a><a name="4996" class="Symbol">)</a><a name="4997"> </a><a name="4998" href="#4998" class="Bound">v</a><a name="4999"> </a><a name="5000" class="Symbol">=</a><a name="5001"> </a><a name="5002" href="#4893" class="Function">permActVec</a><a name="5012"> </a><a name="5013" href="#4994" class="Bound">as</a><a name="5015"> </a><a name="5016" class="Symbol">(</a><a name="5017" href="#4201" class="Function">swapVec</a><a name="5024"> </a><a name="5025" href="#4984" class="Bound">a</a><a name="5026"> </a><a name="5027" href="#4988" class="Bound">b</a><a name="5028"> </a><a name="5029" href="#4998" class="Bound">v</a><a name="5030" class="Symbol">)</a></code></pre>
<p>As we want to equate all permutations, we define the equivalence relation for our coNominal set to simply be the reflexive-symmetric-transitive closure of the relation equating swaps. <code>reflEq</code> and <code>symmEq</code> could both be derived from <code>swapEq</code> and <code>transEq</code>, but out of laziness of proving reflexivity and symmetry I decided to just included the properties definitionally.</p>
<pre class="Agda"><code><a name="5415"></a><a name="5430" class="Keyword">data</a><a name="5434"> </a><a name="5435" href="#5435" class="Datatype">multiSetEq</a><a name="5445">  </a><a name="5447" class="Symbol">{</a><a name="5448" href="#5448" class="Bound">X</a><a name="5449"> </a><a name="5450" class="Symbol">:</a><a name="5451"> </a><a name="5452" class="PrimitiveType">Set</a><a name="5455" class="Symbol">}</a><a name="5456"> </a><a name="5457" class="Symbol">:</a><a name="5458"> </a><a name="5459" class="Symbol">{</a><a name="5460" href="#5460" class="Bound">n</a><a name="5461"> </a><a name="5462" class="Symbol">:</a><a name="5463"> </a><a name="5464" class="Datatype">ℕ</a><a name="5465" class="Symbol">}</a><a name="5466"> </a><a name="5467" class="Symbol">→</a><a name="5468"> </a><a name="5469" class="Function">Rel</a><a name="5472"> </a><a name="5473" class="Symbol">(</a><a name="5474" class="Datatype">Vec</a><a name="5477"> </a><a name="5478" href="#5448" class="Bound">X</a><a name="5479"> </a><a name="5480" href="#5460" class="Bound">n</a><a name="5481" class="Symbol">)</a><a name="5482"> </a><a name="5483" class="Keyword">where</a><a name="5488">
  </a><a name="5491" href="#5491" class="InductiveConstructor">swapEq</a><a name="5497"> </a><a name="5498" class="Symbol">:</a><a name="5499"> </a><a name="5500" class="Symbol">{</a><a name="5501" href="#5501" class="Bound">n</a><a name="5502"> </a><a name="5503" class="Symbol">:</a><a name="5504"> </a><a name="5505" class="Datatype">ℕ</a><a name="5506" class="Symbol">}</a><a name="5507"> </a><a name="5508" class="Symbol">{</a><a name="5509" href="#5509" class="Bound">v</a><a name="5510"> </a><a name="5511" class="Symbol">:</a><a name="5512"> </a><a name="5513" class="Datatype">Vec</a><a name="5516"> </a><a name="5517" href="#5448" class="Bound">X</a><a name="5518"> </a><a name="5519" href="#5501" class="Bound">n</a><a name="5520" class="Symbol">}</a><a name="5521"> </a><a name="5522" class="Symbol">→</a><a name="5523"> </a><a name="5524" class="Symbol">(</a><a name="5525" href="#5525" class="Bound">a</a><a name="5526"> </a><a name="5527" href="#5527" class="Bound">b</a><a name="5528"> </a><a name="5529" class="Symbol">:</a><a name="5530"> </a><a name="5531" class="Datatype">Atom</a><a name="5535" class="Symbol">)</a><a name="5536">
           </a><a name="5548" class="Symbol">→</a><a name="5549"> </a><a name="5550" href="#5435" class="Datatype">multiSetEq</a><a name="5560"> </a><a name="5561" class="Symbol">(</a><a name="5562" href="#4201" class="Function">swapVec</a><a name="5569"> </a><a name="5570" href="#5525" class="Bound">a</a><a name="5571"> </a><a name="5572" href="#5527" class="Bound">b</a><a name="5573"> </a><a name="5574" href="#5509" class="Bound">v</a><a name="5575" class="Symbol">)</a><a name="5576"> </a><a name="5577" href="#5509" class="Bound">v</a><a name="5578">
  </a><a name="5581" href="#5581" class="InductiveConstructor">reflEq</a><a name="5587"> </a><a name="5588" class="Symbol">:</a><a name="5589"> </a><a name="5590" class="Symbol">{</a><a name="5591" href="#5591" class="Bound">n</a><a name="5592"> </a><a name="5593" class="Symbol">:</a><a name="5594"> </a><a name="5595" class="Datatype">ℕ</a><a name="5596" class="Symbol">}</a><a name="5597"> </a><a name="5598" class="Symbol">{</a><a name="5599" href="#5599" class="Bound">v</a><a name="5600"> </a><a name="5601" class="Symbol">:</a><a name="5602"> </a><a name="5603" class="Datatype">Vec</a><a name="5606"> </a><a name="5607" href="#5448" class="Bound">X</a><a name="5608"> </a><a name="5609" href="#5591" class="Bound">n</a><a name="5610" class="Symbol">}</a><a name="5611"> </a><a name="5612" class="Symbol">→</a><a name="5613"> </a><a name="5614" href="#5435" class="Datatype">multiSetEq</a><a name="5624"> </a><a name="5625" href="#5599" class="Bound">v</a><a name="5626"> </a><a name="5627" href="#5599" class="Bound">v</a><a name="5628">
  </a><a name="5631" href="#5631" class="InductiveConstructor">symmEq</a><a name="5637"> </a><a name="5638" class="Symbol">:</a><a name="5639"> </a><a name="5640" class="Symbol">{</a><a name="5641" href="#5641" class="Bound">n</a><a name="5642"> </a><a name="5643" class="Symbol">:</a><a name="5644"> </a><a name="5645" class="Datatype">ℕ</a><a name="5646" class="Symbol">}</a><a name="5647"> </a><a name="5648" class="Symbol">{</a><a name="5649" href="#5649" class="Bound">v1</a><a name="5651"> </a><a name="5652" href="#5652" class="Bound">v2</a><a name="5654"> </a><a name="5655" class="Symbol">:</a><a name="5656"> </a><a name="5657" class="Datatype">Vec</a><a name="5660"> </a><a name="5661" href="#5448" class="Bound">X</a><a name="5662"> </a><a name="5663" href="#5641" class="Bound">n</a><a name="5664" class="Symbol">}</a><a name="5665"> </a><a name="5666" class="Symbol">→</a><a name="5667"> </a><a name="5668" href="#5435" class="Datatype">multiSetEq</a><a name="5678"> </a><a name="5679" href="#5649" class="Bound">v1</a><a name="5681"> </a><a name="5682" href="#5652" class="Bound">v2</a><a name="5684">
            </a><a name="5697" class="Symbol">→</a><a name="5698"> </a><a name="5699" href="#5435" class="Datatype">multiSetEq</a><a name="5709"> </a><a name="5710" href="#5652" class="Bound">v2</a><a name="5712"> </a><a name="5713" href="#5649" class="Bound">v1</a><a name="5715">
  </a><a name="5718" href="#5718" class="InductiveConstructor">transEq</a><a name="5725"> </a><a name="5726" class="Symbol">:</a><a name="5727"> </a><a name="5728" class="Symbol">{</a><a name="5729" href="#5729" class="Bound">n</a><a name="5730"> </a><a name="5731" class="Symbol">:</a><a name="5732"> </a><a name="5733" class="Datatype">ℕ</a><a name="5734" class="Symbol">}</a><a name="5735"> </a><a name="5736" class="Symbol">{</a><a name="5737" href="#5737" class="Bound">v1</a><a name="5739"> </a><a name="5740" href="#5740" class="Bound">v2</a><a name="5742"> </a><a name="5743" href="#5743" class="Bound">v3</a><a name="5745"> </a><a name="5746" class="Symbol">:</a><a name="5747"> </a><a name="5748" class="Datatype">Vec</a><a name="5751"> </a><a name="5752" href="#5448" class="Bound">X</a><a name="5753"> </a><a name="5754" href="#5729" class="Bound">n</a><a name="5755" class="Symbol">}</a><a name="5756"> </a><a name="5757" class="Symbol">→</a><a name="5758"> </a><a name="5759" href="#5435" class="Datatype">multiSetEq</a><a name="5769"> </a><a name="5770" href="#5737" class="Bound">v1</a><a name="5772"> </a><a name="5773" href="#5740" class="Bound">v2</a><a name="5775">
            </a><a name="5788" class="Symbol">→</a><a name="5789"> </a><a name="5790" href="#5435" class="Datatype">multiSetEq</a><a name="5800"> </a><a name="5801" href="#5740" class="Bound">v2</a><a name="5803"> </a><a name="5804" href="#5743" class="Bound">v3</a><a name="5806"> </a><a name="5807" class="Symbol">→</a><a name="5808"> </a><a name="5809" href="#5435" class="Datatype">multiSetEq</a><a name="5819"> </a><a name="5820" href="#5737" class="Bound">v1</a><a name="5822"> </a><a name="5823" href="#5743" class="Bound">v3</a><a name="5825">

</a><a name="5827" href="#5827" class="Function">multiSetCoRes</a><a name="5840"> </a><a name="5841" class="Symbol">:</a><a name="5842"> </a><a name="5843" class="Symbol">(</a><a name="5844" href="#5844" class="Bound">X</a><a name="5845"> </a><a name="5846" class="Symbol">:</a><a name="5847"> </a><a name="5848" class="PrimitiveType">Set</a><a name="5851" class="Symbol">)</a><a name="5852"> </a><a name="5853" class="Symbol">→</a><a name="5854"> </a><a name="5855" class="Symbol">(</a><a name="5856" href="#5856" class="Bound">n</a><a name="5857"> </a><a name="5858" class="Symbol">:</a><a name="5859"> </a><a name="5860" class="Datatype">ℕ</a><a name="5861" class="Symbol">)</a><a name="5862"> </a><a name="5863" class="Symbol">→</a><a name="5864"> </a><a name="5865" class="Symbol">(</a><a name="5866" href="#4893" class="Function">permActVec</a><a name="5876"> </a><a name="5877" class="Symbol">{</a><a name="5878" href="#5844" class="Bound">X</a><a name="5879" class="Symbol">}</a><a name="5880"> </a><a name="5881" class="Symbol">{</a><a name="5882" href="#5856" class="Bound">n</a><a name="5883" class="Symbol">})</a><a name="5885">
                   </a><a name="5905" class="Function Operator">Preserves₂</a><a name="5915"> </a><a name="5916" class="Function">pEquiv</a><a name="5922"> </a><a name="5923" class="Function Operator">⟶</a><a name="5924"> </a><a name="5925" href="#5435" class="Datatype">multiSetEq</a><a name="5935"> </a><a name="5936" class="Function Operator">⟶</a><a name="5937"> </a><a name="5938" href="#5435" class="Datatype">multiSetEq</a><a name="5948">
</a><a name="5949" href="#5827" class="Function">multiSetCoRes</a><a name="5962"> </a><a name="5963" href="#5963" class="Bound">X</a><a name="5964"> </a><a name="5965" href="#5965" class="Bound">n</a><a name="5966"> </a><a name="5967" class="Symbol">{</a><a name="5968" href="#5968" class="Bound">p1</a><a name="5970" class="Symbol">}</a><a name="5971"> </a><a name="5972" class="Symbol">{</a><a name="5973" href="#5973" class="Bound">p2</a><a name="5975" class="Symbol">}</a><a name="5976"> </a><a name="5977" class="Symbol">{</a><a name="5978" href="#5978" class="Bound">v1</a><a name="5980" class="Symbol">}</a><a name="5981"> </a><a name="5982" class="Symbol">{</a><a name="5983" href="#5983" class="Bound">v2</a><a name="5985" class="Symbol">}</a><a name="5986"> </a><a name="5987" href="#5987" class="Bound">q</a><a name="5988"> </a><a name="5989" href="#5989" class="Bound">r</a><a name="5990"> </a><a name="5991" class="Symbol">=</a><a name="5992"> </a><a name="5993" class="Symbol">{!!}</a><a name="5997">

</a><a name="5999" href="#5999" class="Function">multiSetCop₁p₂↠</a><a name="6014"> </a><a name="6015" class="Symbol">:</a><a name="6016"> </a><a name="6017" class="Symbol">(</a><a name="6018" href="#6018" class="Bound">X</a><a name="6019"> </a><a name="6020" class="Symbol">:</a><a name="6021"> </a><a name="6022" class="PrimitiveType">Set</a><a name="6025" class="Symbol">)</a><a name="6026"> </a><a name="6027" class="Symbol">→</a><a name="6028"> </a><a name="6029" class="Symbol">(</a><a name="6030" href="#6030" class="Bound">n</a><a name="6031"> </a><a name="6032" class="Symbol">:</a><a name="6033"> </a><a name="6034" class="Datatype">ℕ</a><a name="6035" class="Symbol">)</a><a name="6036">
                </a><a name="6053" class="Symbol">→</a><a name="6054"> </a><a name="6055" class="Function">p₁p₂Act</a><a name="6062"> </a><a name="6063" class="Symbol">{</a><a name="6064" class="Function">Perm</a><a name="6068" class="Symbol">}</a><a name="6069"> </a><a name="6070" class="Symbol">{</a><a name="6071" class="Datatype">Vec</a><a name="6074"> </a><a name="6075" href="#6018" class="Bound">X</a><a name="6076"> </a><a name="6077" href="#6030" class="Bound">n</a><a name="6078" class="Symbol">}</a><a name="6079"> </a><a name="6080" class="Symbol">{</a><a name="6081" class="Function Operator">_++_</a><a name="6085" class="Symbol">}</a><a name="6086"> </a><a name="6087" class="Symbol">{</a><a name="6088" href="#5435" class="Datatype">multiSetEq</a><a name="6098" class="Symbol">}</a><a name="6099"> </a><a name="6100" class="Symbol">{</a><a name="6101" href="#4893" class="Function">permActVec</a><a name="6111" class="Symbol">}</a><a name="6112">
</a><a name="6113" href="#5999" class="Function">multiSetCop₁p₂↠</a><a name="6128"> </a><a name="6129" href="#6129" class="Bound">X</a><a name="6130"> </a><a name="6131" href="#6131" class="Bound">n</a><a name="6132"> </a><a name="6133" href="#6133" class="Bound">p1</a><a name="6135"> </a><a name="6136" class="InductiveConstructor">[]</a><a name="6138"> </a><a name="6139" class="Symbol">{</a><a name="6140" href="#6140" class="Bound">v</a><a name="6141" class="Symbol">}</a><a name="6142"> </a><a name="6143" class="Symbol">=</a><a name="6144"> </a><a name="6145" href="#5581" class="InductiveConstructor">reflEq</a><a name="6151">
</a><a name="6152" href="#5999" class="Function">multiSetCop₁p₂↠</a><a name="6167"> </a><a name="6168" href="#6168" class="Bound">X</a><a name="6169"> </a><a name="6170" href="#6170" class="Bound">n</a><a name="6171"> </a><a name="6172" href="#6172" class="Bound">p1</a><a name="6174"> </a><a name="6175" class="Symbol">((</a><a name="6177" href="#6177" class="Bound">a</a><a name="6178"> </a><a name="6179" class="InductiveConstructor Operator">,</a><a name="6180"> </a><a name="6181" href="#6181" class="Bound">b</a><a name="6182" class="Symbol">)</a><a name="6183"> </a><a name="6184" class="InductiveConstructor Operator">::</a><a name="6186"> </a><a name="6187" href="#6187" class="Bound">p2</a><a name="6189" class="Symbol">)</a><a name="6190"> </a><a name="6191" class="Symbol">{</a><a name="6192" href="#6192" class="Bound">v</a><a name="6193" class="Symbol">}</a><a name="6194"> </a><a name="6195" class="Symbol">=</a><a name="6196"> </a><a name="6197" class="Symbol">{!!}</a><a name="6201"> </a><a name="6202" class="Comment">-- annoying to prove, but definitely true</a><a name="6243">

</a><a name="6245" href="#6245" class="Function">multiSet</a><a name="6253"> </a><a name="6254" class="Symbol">:</a><a name="6255"> </a><a name="6256" class="PrimitiveType">Set</a><a name="6259"> </a><a name="6260" class="Symbol">→</a><a name="6261"> </a><a name="6262" class="Datatype">ℕ</a><a name="6263"> </a><a name="6264" class="Symbol">→</a><a name="6265"> </a><a name="6266" href="#2040" class="Record">coNominal</a><a name="6275">
</a><a name="6276" href="#6245" class="Function">multiSet</a><a name="6284"> </a><a name="6285" href="#6285" class="Bound">X</a><a name="6286"> </a><a name="6287" href="#6287" class="Bound">n</a><a name="6288"> </a><a name="6289" class="Symbol">=</a><a name="6290"> </a><a name="6291" class="Keyword">record</a><a name="6297"> </a><a name="6298" class="Symbol">{</a><a name="6299"> </a><a name="6300" class="Field">Aˢ</a><a name="6302"> </a><a name="6303" class="Symbol">=</a><a name="6304"> </a><a name="6305" class="Datatype">Vec</a><a name="6308"> </a><a name="6309" href="#6285" class="Bound">X</a><a name="6310"> </a><a name="6311" href="#6287" class="Bound">n</a><a name="6312">
                      </a><a name="6335" class="Symbol">;</a><a name="6336"> </a><a name="6337" class="Field">≈ᵃ</a><a name="6339"> </a><a name="6340" class="Symbol">=</a><a name="6341"> </a><a name="6342" href="#5435" class="Datatype">multiSetEq</a><a name="6352">
                      </a><a name="6375" class="Symbol">;</a><a name="6376"> </a><a name="6377" class="Field">eq≈ᵃ</a><a name="6381"> </a><a name="6382" class="Symbol">=</a><a name="6383"> </a><a name="6384" class="Keyword">record</a><a name="6390"> </a><a name="6391" class="Symbol">{</a><a name="6392"> </a><a name="6393" class="Field">Reflex</a><a name="6399"> </a><a name="6400" class="Symbol">=</a><a name="6401"> </a><a name="6402" href="#5581" class="InductiveConstructor">reflEq</a><a name="6408">
                                      </a><a name="6447" class="Symbol">;</a><a name="6448"> </a><a name="6449" class="Field">Symm</a><a name="6453"> </a><a name="6454" class="Symbol">=</a><a name="6455"> </a><a name="6456" href="#5631" class="InductiveConstructor">symmEq</a><a name="6462">
                                      </a><a name="6501" class="Symbol">;</a><a name="6502"> </a><a name="6503" class="Field">Trans</a><a name="6508"> </a><a name="6509" class="Symbol">=</a><a name="6510"> </a><a name="6511" href="#5718" class="InductiveConstructor">transEq</a><a name="6518"> </a><a name="6519" class="Symbol">}</a><a name="6520">
                      </a><a name="6543" class="Symbol">;</a><a name="6544"> </a><a name="6545" class="Field">coAct</a><a name="6550"> </a><a name="6551" class="Symbol">=</a><a name="6552"> </a><a name="6553" href="#4893" class="Function">permActVec</a><a name="6563">
                      </a><a name="6586" class="Symbol">;</a><a name="6587"> </a><a name="6588" class="Field">coRes</a><a name="6593"> </a><a name="6594" class="Symbol">=</a><a name="6595"> </a><a name="6596" class="Symbol">{!!}</a><a name="6600"> </a><a name="6601" class="Comment">-- annoying to prove, but definitely true</a><a name="6642">
                      </a><a name="6665" class="Symbol">;</a><a name="6666"> </a><a name="6667" class="Field">cop₁p₂↠</a><a name="6674"> </a><a name="6675" class="Symbol">=</a><a name="6676"> </a><a name="6677" href="#5999" class="Function">multiSetCop₁p₂↠</a><a name="6692"> </a><a name="6693" href="#6285" class="Bound">X</a><a name="6694"> </a><a name="6695" href="#6287" class="Bound">n</a><a name="6696">
                      </a><a name="6719" class="Symbol">;</a><a name="6720"> </a><a name="6721" class="Field">coι↠</a><a name="6725"> </a><a name="6726" class="Symbol">=</a><a name="6727"> </a><a name="6728" href="#5581" class="InductiveConstructor">reflEq</a><a name="6734">
         
                      </a><a name="6767" class="Symbol">;</a><a name="6768"> </a><a name="6769" class="Field">coSupp</a><a name="6775"> </a><a name="6776" class="Symbol">=</a><a name="6777"> </a><a name="6778" href="#3233" class="Function">coSuppVec</a><a name="6787">
                      </a><a name="6810" class="Symbol">;</a><a name="6811"> </a><a name="6812" class="Field">coSuppAx</a><a name="6820"> </a><a name="6821" class="Symbol">=</a><a name="6822"> </a><a name="6823" class="Symbol">λ</a><a name="6824"> </a><a name="6825" href="#6825" class="Bound">a</a><a name="6826"> </a><a name="6827" href="#6827" class="Bound">b</a><a name="6828"> </a><a name="6829" href="#6829" class="Bound">c</a><a name="6830"> </a><a name="6831" href="#6831" class="Bound">_</a><a name="6832"> </a><a name="6833" href="#6833" class="Bound">_</a><a name="6834"> </a><a name="6835" class="Symbol">→</a><a name="6836"> </a><a name="6837" href="#5491" class="InductiveConstructor">swapEq</a><a name="6843"> </a><a name="6844" href="#6827" class="Bound">b</a><a name="6845"> </a><a name="6846" href="#6829" class="Bound">c</a><a name="6847"> </a><a name="6848" class="Symbol">}</a><a name="6849">

</a><a name="6851" class="Keyword">data</a><a name="6855"> </a><a name="6856" href="#6856" class="Datatype">Fin</a><a name="6859"> </a><a name="6860" class="Symbol">:</a><a name="6861"> </a><a name="6862" class="Datatype">ℕ</a><a name="6863"> </a><a name="6864" class="Symbol">→</a><a name="6865"> </a><a name="6866" class="PrimitiveType">Set</a><a name="6869"> </a><a name="6870" class="Keyword">where</a><a name="6875">
  </a><a name="6878" href="#6878" class="InductiveConstructor">zero</a><a name="6882">  </a><a name="6884" class="Symbol">:</a><a name="6885"> </a><a name="6886" class="Symbol">{</a><a name="6887" href="#6887" class="Bound">n</a><a name="6888"> </a><a name="6889" class="Symbol">:</a><a name="6890"> </a><a name="6891" class="Datatype">ℕ</a><a name="6892" class="Symbol">}</a><a name="6893"> </a><a name="6894" class="Symbol">→</a><a name="6895"> </a><a name="6896" href="#6856" class="Datatype">Fin</a><a name="6899"> </a><a name="6900" class="Symbol">(</a><a name="6901" class="InductiveConstructor">succ</a><a name="6905"> </a><a name="6906" href="#6887" class="Bound">n</a><a name="6907" class="Symbol">)</a><a name="6908">
  </a><a name="6911" href="#6911" class="InductiveConstructor">succ</a><a name="6915">  </a><a name="6917" class="Symbol">:</a><a name="6918"> </a><a name="6919" class="Symbol">{</a><a name="6920" href="#6920" class="Bound">n</a><a name="6921"> </a><a name="6922" class="Symbol">:</a><a name="6923"> </a><a name="6924" class="Datatype">ℕ</a><a name="6925" class="Symbol">}</a><a name="6926"> </a><a name="6927" class="Symbol">(</a><a name="6928" href="#6928" class="Bound">i</a><a name="6929"> </a><a name="6930" class="Symbol">:</a><a name="6931"> </a><a name="6932" href="#6856" class="Datatype">Fin</a><a name="6935"> </a><a name="6936" href="#6920" class="Bound">n</a><a name="6937" class="Symbol">)</a><a name="6938"> </a><a name="6939" class="Symbol">→</a><a name="6940"> </a><a name="6941" href="#6856" class="Datatype">Fin</a><a name="6944"> </a><a name="6945" class="Symbol">(</a><a name="6946" class="InductiveConstructor">succ</a><a name="6950"> </a><a name="6951" href="#6920" class="Bound">n</a><a name="6952" class="Symbol">)</a><a name="6953">

</a><a name="6955" href="#6955" class="Function">multiGraph₁</a><a name="6966"> </a><a name="6967" class="Symbol">:</a><a name="6968"> </a><a name="6969" class="Datatype">ℕ</a><a name="6970"> </a><a name="6971" class="Symbol">→</a><a name="6972"> </a><a name="6973" class="Datatype">ℕ</a><a name="6974"> </a><a name="6975" class="Symbol">→</a><a name="6976"> </a><a name="6977" href="#2040" class="Record">coNominal</a><a name="6986">
</a><a name="6987" href="#6955" class="Function">multiGraph₁</a><a name="6998"> </a><a name="6999" href="#6999" class="Bound">n</a><a name="7000"> </a><a name="7001" class="Symbol">=</a><a name="7002"> </a><a name="7003" href="#6245" class="Function">multiSet</a><a name="7011"> </a><a name="7012" class="Symbol">((</a><a name="7014" href="#6856" class="Datatype">Fin</a><a name="7017"> </a><a name="7018" href="#6999" class="Bound">n</a><a name="7019" class="Symbol">)</a><a name="7020"> </a><a name="7021" class="Function Operator">×</a><a name="7022"> </a><a name="7023" class="Symbol">(</a><a name="7024" href="#6856" class="Datatype">Fin</a><a name="7027"> </a><a name="7028" href="#6999" class="Bound">n</a><a name="7029" class="Symbol">))</a></code></pre>
<p><code>multiGraph₁</code> is a coNominal set representing multigraphs, indexed by both the number of vertices and edges, quotiented so that the order of the edges in the list of edges makes no difference; however, to have a fully abstract notion of multigraph, we must also equate all multigraphs that have the same shape with different labels associated with each node.</p>
<pre class="Agda"><code><a name="7402">
</a><a name="7418" href="#7418" class="Function">coSuppFin</a><a name="7427"> </a><a name="7428" class="Symbol">:</a><a name="7429"> </a><a name="7430" class="Datatype">ℕ</a><a name="7431"> </a><a name="7432" class="Symbol">→</a><a name="7433"> </a><a name="7434" class="Datatype">List</a><a name="7438"> </a><a name="7439" class="Datatype">Atom</a><a name="7443">
</a><a name="7444" href="#7418" class="Function">coSuppFin</a><a name="7453"> </a><a name="7454" class="InductiveConstructor">zero</a><a name="7458"> </a><a name="7459" class="Symbol">=</a><a name="7460"> </a><a name="7461" class="InductiveConstructor">[]</a><a name="7463">
</a><a name="7464" href="#7418" class="Function">coSuppFin</a><a name="7473"> </a><a name="7474" class="Symbol">(</a><a name="7475" class="InductiveConstructor">succ</a><a name="7479"> </a><a name="7480" href="#7480" class="Bound">n</a><a name="7481" class="Symbol">)</a><a name="7482"> </a><a name="7483" class="Symbol">=</a><a name="7484"> </a><a name="7485" href="#3127" class="Function">AtListSucc</a><a name="7495"> </a><a name="7496" class="Symbol">(</a><a name="7497" href="#7418" class="Function">coSuppFin</a><a name="7506"> </a><a name="7507" href="#7480" class="Bound">n</a><a name="7508" class="Symbol">)</a><a name="7509">

</a><a name="7511" href="#7511" class="Function">toℕ</a><a name="7514"> </a><a name="7515" class="Symbol">:</a><a name="7516"> </a><a name="7517" class="Symbol">{</a><a name="7518" href="#7518" class="Bound">n</a><a name="7519"> </a><a name="7520" class="Symbol">:</a><a name="7521"> </a><a name="7522" class="Datatype">ℕ</a><a name="7523" class="Symbol">}</a><a name="7524"> </a><a name="7525" class="Symbol">→</a><a name="7526"> </a><a name="7527" href="#6856" class="Datatype">Fin</a><a name="7530"> </a><a name="7531" href="#7518" class="Bound">n</a><a name="7532"> </a><a name="7533" class="Symbol">→</a><a name="7534"> </a><a name="7535" class="Datatype">ℕ</a><a name="7536">
</a><a name="7537" href="#7511" class="Function">toℕ</a><a name="7540"> </a><a name="7541" href="#6878" class="InductiveConstructor">zero</a><a name="7545"> </a><a name="7546" class="Symbol">=</a><a name="7547"> </a><a name="7548" class="InductiveConstructor">zero</a><a name="7552">
</a><a name="7553" href="#7511" class="Function">toℕ</a><a name="7556"> </a><a name="7557" class="Symbol">(</a><a name="7558" href="#6911" class="InductiveConstructor">succ</a><a name="7562"> </a><a name="7563" href="#7563" class="Bound">f</a><a name="7564" class="Symbol">)</a><a name="7565"> </a><a name="7566" class="Symbol">=</a><a name="7567"> </a><a name="7568" class="InductiveConstructor">succ</a><a name="7572"> </a><a name="7573" class="Symbol">(</a><a name="7574" href="#7511" class="Function">toℕ</a><a name="7577"> </a><a name="7578" href="#7563" class="Bound">f</a><a name="7579" class="Symbol">)</a><a name="7580">

</a><a name="7582" href="#7582" class="Function">pred</a><a name="7586"> </a><a name="7587" class="Symbol">:</a><a name="7588"> </a><a name="7589" class="Datatype">ℕ</a><a name="7590"> </a><a name="7591" class="Symbol">→</a><a name="7592"> </a><a name="7593" class="Datatype">ℕ</a><a name="7594">
</a><a name="7595" href="#7582" class="Function">pred</a><a name="7599"> </a><a name="7600" class="InductiveConstructor">zero</a><a name="7604">     </a><a name="7609" class="Symbol">=</a><a name="7610"> </a><a name="7611" class="InductiveConstructor">zero</a><a name="7615">
</a><a name="7616" href="#7582" class="Function">pred</a><a name="7620"> </a><a name="7621" class="Symbol">(</a><a name="7622" class="InductiveConstructor">succ</a><a name="7626"> </a><a name="7627" href="#7627" class="Bound">n</a><a name="7628" class="Symbol">)</a><a name="7629"> </a><a name="7630" class="Symbol">=</a><a name="7631"> </a><a name="7632" href="#7627" class="Bound">n</a><a name="7633">

</a><a name="7635" href="#7635" class="Function">decEqNat</a><a name="7643"> </a><a name="7644" class="Symbol">:</a><a name="7645"> </a><a name="7646" class="Symbol">(</a><a name="7647" href="#7647" class="Bound">m</a><a name="7648"> </a><a name="7649" href="#7649" class="Bound">n</a><a name="7650"> </a><a name="7651" class="Symbol">:</a><a name="7652"> </a><a name="7653" class="Datatype">ℕ</a><a name="7654" class="Symbol">)</a><a name="7655"> </a><a name="7656" class="Symbol">→</a><a name="7657"> </a><a name="7658" class="Datatype">Dec</a><a name="7661"> </a><a name="7662" class="Symbol">(</a><a name="7663" href="#7647" class="Bound">m</a><a name="7664"> </a><a name="7665" class="Datatype Operator">≡</a><a name="7666"> </a><a name="7667" href="#7649" class="Bound">n</a><a name="7668" class="Symbol">)</a><a name="7669">
</a><a name="7670" href="#7635" class="Function">decEqNat</a><a name="7678"> </a><a name="7679" class="InductiveConstructor">zero</a><a name="7683"> </a><a name="7684" class="InductiveConstructor">zero</a><a name="7688"> </a><a name="7689" class="Symbol">=</a><a name="7690"> </a><a name="7691" class="InductiveConstructor">yes</a><a name="7694"> </a><a name="7695" class="InductiveConstructor">refl</a><a name="7699">
</a><a name="7700" href="#7635" class="Function">decEqNat</a><a name="7708"> </a><a name="7709" class="InductiveConstructor">zero</a><a name="7713"> </a><a name="7714" class="Symbol">(</a><a name="7715" class="InductiveConstructor">succ</a><a name="7719"> </a><a name="7720" href="#7720" class="Bound">n</a><a name="7721" class="Symbol">)</a><a name="7722"> </a><a name="7723" class="Symbol">=</a><a name="7724"> </a><a name="7725" class="InductiveConstructor">no</a><a name="7727"> </a><a name="7728" class="Symbol">(λ</a><a name="7730"> </a><a name="7731" class="Symbol">())</a><a name="7734">
</a><a name="7735" href="#7635" class="Function">decEqNat</a><a name="7743"> </a><a name="7744" class="Symbol">(</a><a name="7745" class="InductiveConstructor">succ</a><a name="7749"> </a><a name="7750" href="#7750" class="Bound">m</a><a name="7751" class="Symbol">)</a><a name="7752"> </a><a name="7753" class="InductiveConstructor">zero</a><a name="7757"> </a><a name="7758" class="Symbol">=</a><a name="7759"> </a><a name="7760" class="InductiveConstructor">no</a><a name="7762"> </a><a name="7763" class="Symbol">(λ</a><a name="7765"> </a><a name="7766" class="Symbol">())</a><a name="7769">
</a><a name="7770" href="#7635" class="Function">decEqNat</a><a name="7778"> </a><a name="7779" class="Symbol">(</a><a name="7780" class="InductiveConstructor">succ</a><a name="7784"> </a><a name="7785" href="#7785" class="Bound">m</a><a name="7786" class="Symbol">)</a><a name="7787"> </a><a name="7788" class="Symbol">(</a><a name="7789" class="InductiveConstructor">succ</a><a name="7793"> </a><a name="7794" href="#7794" class="Bound">n</a><a name="7795" class="Symbol">)</a><a name="7796"> </a><a name="7797" class="Keyword">with</a><a name="7801"> </a><a name="7802" href="#7635" class="Function">decEqNat</a><a name="7810"> </a><a name="7811" href="#7785" class="Bound">m</a><a name="7812"> </a><a name="7813" href="#7794" class="Bound">n</a><a name="7814">
</a><a name="7815" href="#7635" class="Function">decEqNat</a><a name="7823"> </a><a name="7824" class="Symbol">(</a><a name="7825" class="InductiveConstructor">succ</a><a name="7829"> </a><a name="7830" href="#7830" class="Bound">m</a><a name="7831" class="Symbol">)</a><a name="7832"> </a><a name="7833" class="Symbol">(</a><a name="7834" class="InductiveConstructor">succ</a><a name="7838"> </a><a name="7839" class="DottedPattern Symbol">.</a><a name="7840" href="#7830" class="DottedPattern Bound">m</a><a name="7841" class="Symbol">)</a><a name="7842"> </a><a name="7843" class="Symbol">|</a><a name="7844"> </a><a name="7845" class="InductiveConstructor">yes</a><a name="7848"> </a><a name="7849" class="InductiveConstructor">refl</a><a name="7853"> </a><a name="7854" class="Symbol">=</a><a name="7855"> </a><a name="7856" class="InductiveConstructor">yes</a><a name="7859"> </a><a name="7860" class="InductiveConstructor">refl</a><a name="7864">
</a><a name="7865" href="#7635" class="Function">decEqNat</a><a name="7873"> </a><a name="7874" class="Symbol">(</a><a name="7875" class="InductiveConstructor">succ</a><a name="7879"> </a><a name="7880" href="#7880" class="Bound">m</a><a name="7881" class="Symbol">)</a><a name="7882"> </a><a name="7883" class="Symbol">(</a><a name="7884" class="InductiveConstructor">succ</a><a name="7888">  </a><a name="7890" href="#7890" class="Bound">n</a><a name="7891" class="Symbol">)</a><a name="7892"> </a><a name="7893" class="Symbol">|</a><a name="7894"> </a><a name="7895" class="InductiveConstructor">no</a><a name="7897">  </a><a name="7899" href="#7899" class="Bound">p</a><a name="7900">    </a><a name="7904" class="Symbol">=</a><a name="7905"> </a><a name="7906" class="InductiveConstructor">no</a><a name="7908"> </a><a name="7909" class="Symbol">((</a><a name="7911" href="#7899" class="Bound">p</a><a name="7912"> </a><a name="7913" class="Function Operator">∘</a><a name="7914"> </a><a name="7915" class="Function">cong</a><a name="7919"> </a><a name="7920" href="#7582" class="Function">pred</a><a name="7924" class="Symbol">))</a><a name="7926">

</a><a name="7928" href="#7928" class="Function">AtoFin</a><a name="7934"> </a><a name="7935" class="Symbol">:</a><a name="7936"> </a><a name="7937" class="Symbol">{</a><a name="7938" href="#7938" class="Bound">n</a><a name="7939"> </a><a name="7940" class="Symbol">:</a><a name="7941"> </a><a name="7942" class="Datatype">ℕ</a><a name="7943" class="Symbol">}</a><a name="7944"> </a><a name="7945" class="Symbol">→</a><a name="7946"> </a><a name="7947" class="Symbol">(</a><a name="7948" href="#7948" class="Bound">a</a><a name="7949"> </a><a name="7950" class="Symbol">:</a><a name="7951"> </a><a name="7952" class="Datatype">Atom</a><a name="7956" class="Symbol">)</a><a name="7957"> </a><a name="7958" class="Symbol">→</a><a name="7959"> </a><a name="7960" class="Symbol">(</a><a name="7961" class="InductiveConstructor">succ</a><a name="7965"> </a><a name="7966" class="Symbol">(</a><a name="7967" href="#3059" class="Function">Atoℕ</a><a name="7971"> </a><a name="7972" href="#7948" class="Bound">a</a><a name="7973" class="Symbol">))</a><a name="7975"> </a><a name="7976" href="#2563" class="Datatype Operator">≤</a><a name="7977"> </a><a name="7978" href="#7938" class="Bound">n</a><a name="7979"> </a><a name="7980" class="Symbol">→</a><a name="7981"> </a><a name="7982" href="#6856" class="Datatype">Fin</a><a name="7985"> </a><a name="7986" href="#7938" class="Bound">n</a><a name="7987">
</a><a name="7988" href="#7928" class="Function">AtoFin</a><a name="7994"> </a><a name="7995" class="Symbol">{</a><a name="7996" class="InductiveConstructor">zero</a><a name="8000" class="Symbol">}</a><a name="8001"> </a><a name="8002" href="#8002" class="Bound">a</a><a name="8003"> </a><a name="8004" class="Symbol">()</a><a name="8006">
</a><a name="8007" href="#7928" class="Function">AtoFin</a><a name="8013"> </a><a name="8014" class="Symbol">{</a><a name="8015" class="InductiveConstructor">succ</a><a name="8019"> </a><a name="8020" href="#8020" class="Bound">n</a><a name="8021" class="Symbol">}</a><a name="8022"> </a><a name="8023" class="InductiveConstructor">root</a><a name="8027"> </a><a name="8028" href="#8028" class="Bound">p</a><a name="8029"> </a><a name="8030" class="Symbol">=</a><a name="8031"> </a><a name="8032" href="#6878" class="InductiveConstructor">zero</a><a name="8036">
</a><a name="8037" href="#7928" class="Function">AtoFin</a><a name="8043"> </a><a name="8044" class="Symbol">{</a><a name="8045" class="InductiveConstructor">succ</a><a name="8049"> </a><a name="8050" href="#8050" class="Bound">n</a><a name="8051" class="Symbol">}</a><a name="8052"> </a><a name="8053" class="Symbol">(</a><a name="8054" class="InductiveConstructor">next</a><a name="8058"> </a><a name="8059" href="#8059" class="Bound">a</a><a name="8060" class="Symbol">)</a><a name="8061"> </a><a name="8062" class="Symbol">(</a><a name="8063" href="#2618" class="InductiveConstructor">≤succ</a><a name="8068"> </a><a name="8069" href="#8069" class="Bound">p</a><a name="8070" class="Symbol">)</a><a name="8071"> </a><a name="8072" class="Symbol">=</a><a name="8073"> </a><a name="8074" href="#6911" class="InductiveConstructor">succ</a><a name="8078"> </a><a name="8079" class="Symbol">(</a><a name="8080" href="#7928" class="Function">AtoFin</a><a name="8086"> </a><a name="8087" class="Symbol">{</a><a name="8088" href="#8050" class="Bound">n</a><a name="8089" class="Symbol">}</a><a name="8090"> </a><a name="8091" href="#8059" class="Bound">a</a><a name="8092"> </a><a name="8093" href="#8069" class="Bound">p</a><a name="8094" class="Symbol">)</a><a name="8095">

</a><a name="8097" href="#8097" class="Function">swapFin</a><a name="8104"> </a><a name="8105" class="Symbol">:</a><a name="8106"> </a><a name="8107" class="Symbol">{</a><a name="8108" href="#8108" class="Bound">n</a><a name="8109"> </a><a name="8110" class="Symbol">:</a><a name="8111"> </a><a name="8112" class="Datatype">ℕ</a><a name="8113" class="Symbol">}</a><a name="8114"> </a><a name="8115" class="Symbol">→</a><a name="8116"> </a><a name="8117" class="Datatype">Atom</a><a name="8121"> </a><a name="8122" class="Symbol">→</a><a name="8123"> </a><a name="8124" class="Datatype">Atom</a><a name="8128"> </a><a name="8129" class="Symbol">→</a><a name="8130"> </a><a name="8131" href="#6856" class="Datatype">Fin</a><a name="8134"> </a><a name="8135" href="#8108" class="Bound">n</a><a name="8136"> </a><a name="8137" class="Symbol">→</a><a name="8138"> </a><a name="8139" href="#6856" class="Datatype">Fin</a><a name="8142"> </a><a name="8143" href="#8108" class="Bound">n</a><a name="8144">
</a><a name="8145" href="#8097" class="Function">swapFin</a><a name="8152"> </a><a name="8153" class="Symbol">{</a><a name="8154" href="#8154" class="Bound">n</a><a name="8155" class="Symbol">}</a><a name="8156"> </a><a name="8157" href="#8157" class="Bound">a</a><a name="8158"> </a><a name="8159" href="#8159" class="Bound">b</a><a name="8160"> </a><a name="8161" href="#8161" class="Bound">f</a><a name="8162"> </a><a name="8163" class="Keyword">with</a><a name="8167"> </a><a name="8168" href="#2782" class="Function">dec≤</a><a name="8172"> </a><a name="8173" class="Symbol">(</a><a name="8174" class="InductiveConstructor">succ</a><a name="8178"> </a><a name="8179" class="Symbol">(</a><a name="8180" href="#3059" class="Function">Atoℕ</a><a name="8184"> </a><a name="8185" href="#8157" class="Bound">a</a><a name="8186" class="Symbol">))</a><a name="8188"> </a><a name="8189" href="#8154" class="Bound">n</a><a name="8190"> </a><a name="8191" class="Symbol">|</a><a name="8192"> </a><a name="8193" href="#2782" class="Function">dec≤</a><a name="8197"> </a><a name="8198" class="Symbol">(</a><a name="8199" class="InductiveConstructor">succ</a><a name="8203"> </a><a name="8204" class="Symbol">(</a><a name="8205" href="#3059" class="Function">Atoℕ</a><a name="8209"> </a><a name="8210" href="#8159" class="Bound">b</a><a name="8211" class="Symbol">))</a><a name="8213"> </a><a name="8214" href="#8154" class="Bound">n</a><a name="8215">
</a><a name="8216" href="#8097" class="Function">swapFin</a><a name="8223"> </a><a name="8224" href="#8224" class="Bound">a</a><a name="8225"> </a><a name="8226" href="#8226" class="Bound">b</a><a name="8227"> </a><a name="8228" href="#8228" class="Bound">f</a><a name="8229"> </a><a name="8230" class="Symbol">|</a><a name="8231"> </a><a name="8232" class="InductiveConstructor">yes</a><a name="8235"> </a><a name="8236" href="#8236" class="Bound">p</a><a name="8237"> </a><a name="8238" class="Symbol">|</a><a name="8239"> </a><a name="8240" class="InductiveConstructor">yes</a><a name="8243"> </a><a name="8244" href="#8244" class="Bound">q</a><a name="8245"> </a><a name="8246" class="Keyword">with</a><a name="8250"> </a><a name="8251" href="#7635" class="Function">decEqNat</a><a name="8259"> </a><a name="8260" class="Symbol">(</a><a name="8261" href="#3059" class="Function">Atoℕ</a><a name="8265"> </a><a name="8266" href="#8224" class="Bound">a</a><a name="8267" class="Symbol">)</a><a name="8268"> </a><a name="8269" class="Symbol">(</a><a name="8270" href="#7511" class="Function">toℕ</a><a name="8273"> </a><a name="8274" href="#8228" class="Bound">f</a><a name="8275" class="Symbol">)</a><a name="8276">
                                 </a><a name="8310" class="Symbol">|</a><a name="8311"> </a><a name="8312" href="#7635" class="Function">decEqNat</a><a name="8320"> </a><a name="8321" class="Symbol">(</a><a name="8322" href="#3059" class="Function">Atoℕ</a><a name="8326"> </a><a name="8327" href="#8226" class="Bound">b</a><a name="8328" class="Symbol">)</a><a name="8329"> </a><a name="8330" class="Symbol">(</a><a name="8331" href="#7511" class="Function">toℕ</a><a name="8334"> </a><a name="8335" href="#8228" class="Bound">f</a><a name="8336" class="Symbol">)</a><a name="8337">
</a><a name="8338" href="#8097" class="Function">swapFin</a><a name="8345"> </a><a name="8346" href="#8346" class="Bound">a</a><a name="8347"> </a><a name="8348" href="#8348" class="Bound">b</a><a name="8349"> </a><a name="8350" href="#8350" class="Bound">f</a><a name="8351"> </a><a name="8352" class="Symbol">|</a><a name="8353"> </a><a name="8354" class="InductiveConstructor">yes</a><a name="8357"> </a><a name="8358" href="#8358" class="Bound">p</a><a name="8359"> </a><a name="8360" class="Symbol">|</a><a name="8361"> </a><a name="8362" class="InductiveConstructor">yes</a><a name="8365"> </a><a name="8366" href="#8366" class="Bound">q</a><a name="8367"> </a><a name="8368" class="Symbol">|</a><a name="8369"> </a><a name="8370" class="InductiveConstructor">yes</a><a name="8373"> </a><a name="8374" href="#8374" class="Bound">r</a><a name="8375"> </a><a name="8376" class="Symbol">|</a><a name="8377"> </a><a name="8378" class="Symbol">_</a><a name="8379">     </a><a name="8384" class="Symbol">=</a><a name="8385"> </a><a name="8386" href="#7928" class="Function">AtoFin</a><a name="8392"> </a><a name="8393" href="#8348" class="Bound">b</a><a name="8394"> </a><a name="8395" href="#8366" class="Bound">q</a><a name="8396">
</a><a name="8397" href="#8097" class="Function">swapFin</a><a name="8404"> </a><a name="8405" href="#8405" class="Bound">a</a><a name="8406"> </a><a name="8407" href="#8407" class="Bound">b</a><a name="8408"> </a><a name="8409" href="#8409" class="Bound">f</a><a name="8410"> </a><a name="8411" class="Symbol">|</a><a name="8412"> </a><a name="8413" class="InductiveConstructor">yes</a><a name="8416"> </a><a name="8417" href="#8417" class="Bound">p</a><a name="8418"> </a><a name="8419" class="Symbol">|</a><a name="8420"> </a><a name="8421" class="InductiveConstructor">yes</a><a name="8424"> </a><a name="8425" href="#8425" class="Bound">q</a><a name="8426"> </a><a name="8427" class="Symbol">|</a><a name="8428"> </a><a name="8429" class="Symbol">_</a><a name="8430">     </a><a name="8435" class="Symbol">|</a><a name="8436"> </a><a name="8437" class="InductiveConstructor">yes</a><a name="8440"> </a><a name="8441" href="#8441" class="Bound">r</a><a name="8442"> </a><a name="8443" class="Symbol">=</a><a name="8444"> </a><a name="8445" href="#7928" class="Function">AtoFin</a><a name="8451"> </a><a name="8452" href="#8405" class="Bound">a</a><a name="8453"> </a><a name="8454" href="#8417" class="Bound">p</a><a name="8455">
</a><a name="8456" href="#8097" class="Function">swapFin</a><a name="8463"> </a><a name="8464" href="#8464" class="Bound">a</a><a name="8465"> </a><a name="8466" href="#8466" class="Bound">b</a><a name="8467"> </a><a name="8468" href="#8468" class="Bound">f</a><a name="8469"> </a><a name="8470" class="Symbol">|</a><a name="8471"> </a><a name="8472" class="InductiveConstructor">yes</a><a name="8475"> </a><a name="8476" href="#8476" class="Bound">p</a><a name="8477"> </a><a name="8478" class="Symbol">|</a><a name="8479"> </a><a name="8480" class="InductiveConstructor">yes</a><a name="8483"> </a><a name="8484" href="#8484" class="Bound">q</a><a name="8485"> </a><a name="8486" class="Symbol">|</a><a name="8487"> </a><a name="8488" class="Symbol">_</a><a name="8489">     </a><a name="8494" class="Symbol">|</a><a name="8495"> </a><a name="8496" class="Symbol">_</a><a name="8497">     </a><a name="8502" class="Symbol">=</a><a name="8503"> </a><a name="8504" href="#8468" class="Bound">f</a><a name="8505">
</a><a name="8506" href="#8097" class="Function">swapFin</a><a name="8513"> </a><a name="8514" href="#8514" class="Bound">a</a><a name="8515"> </a><a name="8516" href="#8516" class="Bound">b</a><a name="8517"> </a><a name="8518" href="#8518" class="Bound">f</a><a name="8519"> </a><a name="8520" class="Symbol">|</a><a name="8521"> </a><a name="8522" class="Symbol">_</a><a name="8523">     </a><a name="8528" class="Symbol">|</a><a name="8529"> </a><a name="8530" class="Symbol">_</a><a name="8531">     </a><a name="8536" class="Symbol">=</a><a name="8537"> </a><a name="8538" href="#8518" class="Bound">f</a><a name="8539">

</a><a name="8541" href="#8541" class="Function">swapVecFin</a><a name="8551"> </a><a name="8552" class="Symbol">:</a><a name="8553"> </a><a name="8554" class="Symbol">{</a><a name="8555" href="#8555" class="Bound">v</a><a name="8556"> </a><a name="8557" href="#8557" class="Bound">e</a><a name="8558"> </a><a name="8559" class="Symbol">:</a><a name="8560"> </a><a name="8561" class="Datatype">ℕ</a><a name="8562" class="Symbol">}</a><a name="8563"> </a><a name="8564" class="Symbol">→</a><a name="8565"> </a><a name="8566" class="Datatype">Atom</a><a name="8570"> </a><a name="8571" class="Symbol">→</a><a name="8572"> </a><a name="8573" class="Datatype">Atom</a><a name="8577"> </a><a name="8578" class="Symbol">→</a><a name="8579"> </a><a name="8580" class="Datatype">Vec</a><a name="8583"> </a><a name="8584" class="Symbol">((</a><a name="8586" href="#6856" class="Datatype">Fin</a><a name="8589"> </a><a name="8590" href="#8555" class="Bound">v</a><a name="8591" class="Symbol">)</a><a name="8592"> </a><a name="8593" class="Function Operator">×</a><a name="8594"> </a><a name="8595" class="Symbol">(</a><a name="8596" href="#6856" class="Datatype">Fin</a><a name="8599"> </a><a name="8600" href="#8555" class="Bound">v</a><a name="8601" class="Symbol">))</a><a name="8603"> </a><a name="8604" href="#8557" class="Bound">e</a><a name="8605">
             </a><a name="8619" class="Symbol">→</a><a name="8620"> </a><a name="8621" class="Datatype">Vec</a><a name="8624"> </a><a name="8625" class="Symbol">((</a><a name="8627" href="#6856" class="Datatype">Fin</a><a name="8630"> </a><a name="8631" href="#8555" class="Bound">v</a><a name="8632" class="Symbol">)</a><a name="8633"> </a><a name="8634" class="Function Operator">×</a><a name="8635"> </a><a name="8636" class="Symbol">(</a><a name="8637" href="#6856" class="Datatype">Fin</a><a name="8640"> </a><a name="8641" href="#8555" class="Bound">v</a><a name="8642" class="Symbol">))</a><a name="8644"> </a><a name="8645" href="#8557" class="Bound">e</a><a name="8646">
</a><a name="8647" href="#8541" class="Function">swapVecFin</a><a name="8657"> </a><a name="8658" href="#8658" class="Bound">a</a><a name="8659"> </a><a name="8660" href="#8660" class="Bound">b</a><a name="8661"> </a><a name="8662" class="InductiveConstructor">[]</a><a name="8664"> </a><a name="8665" class="Symbol">=</a><a name="8666"> </a><a name="8667" class="InductiveConstructor">[]</a><a name="8669">
</a><a name="8670" href="#8541" class="Function">swapVecFin</a><a name="8680"> </a><a name="8681" class="Symbol">{</a><a name="8682" href="#8682" class="Bound">v</a><a name="8683" class="Symbol">}</a><a name="8684"> </a><a name="8685" href="#8685" class="Bound">a</a><a name="8686"> </a><a name="8687" href="#8687" class="Bound">b</a><a name="8688"> </a><a name="8689" class="Symbol">((</a><a name="8691" href="#8691" class="Bound">x</a><a name="8692"> </a><a name="8693" class="InductiveConstructor Operator">,</a><a name="8694"> </a><a name="8695" href="#8695" class="Bound">y</a><a name="8696" class="Symbol">)</a><a name="8697"> </a><a name="8698" class="InductiveConstructor Operator">::</a><a name="8700"> </a><a name="8701" href="#8701" class="Bound">g</a><a name="8702" class="Symbol">)</a><a name="8703"> </a><a name="8704" class="Keyword">with</a><a name="8708"> </a><a name="8709" href="#2782" class="Function">dec≤</a><a name="8713"> </a><a name="8714" class="Symbol">(</a><a name="8715" class="InductiveConstructor">succ</a><a name="8719"> </a><a name="8720" class="Symbol">(</a><a name="8721" href="#3059" class="Function">Atoℕ</a><a name="8725"> </a><a name="8726" href="#8685" class="Bound">a</a><a name="8727" class="Symbol">))</a><a name="8729"> </a><a name="8730" href="#8682" class="Bound">v</a><a name="8731">
                                     </a><a name="8769" class="Symbol">|</a><a name="8770"> </a><a name="8771" href="#2782" class="Function">dec≤</a><a name="8775"> </a><a name="8776" class="Symbol">(</a><a name="8777" class="InductiveConstructor">succ</a><a name="8781"> </a><a name="8782" class="Symbol">(</a><a name="8783" href="#3059" class="Function">Atoℕ</a><a name="8787"> </a><a name="8788" href="#8687" class="Bound">b</a><a name="8789" class="Symbol">))</a><a name="8791"> </a><a name="8792" href="#8682" class="Bound">v</a><a name="8793">
</a><a name="8794" href="#8541" class="Function">swapVecFin</a><a name="8804"> </a><a name="8805" href="#8805" class="Bound">a</a><a name="8806"> </a><a name="8807" href="#8807" class="Bound">b</a><a name="8808"> </a><a name="8809" class="Symbol">((</a><a name="8811" href="#8811" class="Bound">x</a><a name="8812"> </a><a name="8813" class="InductiveConstructor Operator">,</a><a name="8814"> </a><a name="8815" href="#8815" class="Bound">y</a><a name="8816" class="Symbol">)</a><a name="8817"> </a><a name="8818" class="InductiveConstructor Operator">::</a><a name="8820"> </a><a name="8821" href="#8821" class="Bound">g</a><a name="8822" class="Symbol">)</a><a name="8823"> </a><a name="8824" class="Symbol">|</a><a name="8825"> </a><a name="8826" class="InductiveConstructor">yes</a><a name="8829"> </a><a name="8830" href="#8830" class="Bound">p</a><a name="8831"> </a><a name="8832" class="Symbol">|</a><a name="8833"> </a><a name="8834" class="InductiveConstructor">yes</a><a name="8837"> </a><a name="8838" href="#8838" class="Bound">q</a><a name="8839">
                              </a><a name="8870" class="Symbol">=</a><a name="8871"> </a><a name="8872" class="Symbol">(</a><a name="8873" href="#8097" class="Function">swapFin</a><a name="8880"> </a><a name="8881" href="#8805" class="Bound">a</a><a name="8882"> </a><a name="8883" href="#8807" class="Bound">b</a><a name="8884"> </a><a name="8885" href="#8811" class="Bound">x</a><a name="8886"> </a><a name="8887" class="InductiveConstructor Operator">,</a><a name="8888"> </a><a name="8889" href="#8097" class="Function">swapFin</a><a name="8896"> </a><a name="8897" href="#8805" class="Bound">a</a><a name="8898"> </a><a name="8899" href="#8807" class="Bound">b</a><a name="8900"> </a><a name="8901" href="#8815" class="Bound">y</a><a name="8902" class="Symbol">)</a><a name="8903"> </a><a name="8904" class="InductiveConstructor Operator">::</a><a name="8906"> </a><a name="8907" class="Symbol">(</a><a name="8908" href="#8541" class="Function">swapVecFin</a><a name="8918"> </a><a name="8919" href="#8805" class="Bound">a</a><a name="8920"> </a><a name="8921" href="#8807" class="Bound">b</a><a name="8922"> </a><a name="8923" href="#8821" class="Bound">g</a><a name="8924" class="Symbol">)</a><a name="8925"> 
</a><a name="8927" href="#8541" class="Function">swapVecFin</a><a name="8937"> </a><a name="8938" href="#8938" class="Bound">a</a><a name="8939"> </a><a name="8940" href="#8940" class="Bound">b</a><a name="8941"> </a><a name="8942" class="Symbol">((</a><a name="8944" href="#8944" class="Bound">x</a><a name="8945"> </a><a name="8946" class="InductiveConstructor Operator">,</a><a name="8947"> </a><a name="8948" href="#8948" class="Bound">y</a><a name="8949" class="Symbol">)</a><a name="8950"> </a><a name="8951" class="InductiveConstructor Operator">::</a><a name="8953"> </a><a name="8954" href="#8954" class="Bound">g</a><a name="8955" class="Symbol">)</a><a name="8956"> </a><a name="8957" class="Symbol">|</a><a name="8958"> </a><a name="8959" class="Symbol">_</a><a name="8960">     </a><a name="8965" class="Symbol">|</a><a name="8966"> </a><a name="8967" class="Symbol">_</a><a name="8968">     </a><a name="8973" class="Symbol">=</a><a name="8974"> </a><a name="8975" class="Symbol">((</a><a name="8977" href="#8944" class="Bound">x</a><a name="8978"> </a><a name="8979" class="InductiveConstructor Operator">,</a><a name="8980"> </a><a name="8981" href="#8948" class="Bound">y</a><a name="8982" class="Symbol">)</a><a name="8983"> </a><a name="8984" class="InductiveConstructor Operator">::</a><a name="8986"> </a><a name="8987" href="#8954" class="Bound">g</a><a name="8988" class="Symbol">)</a><a name="8989">

 
</a><a name="8993" href="#8993" class="Function">permActFin</a><a name="9003"> </a><a name="9004" class="Symbol">:</a><a name="9005"> </a><a name="9006" class="Symbol">{</a><a name="9007" href="#9007" class="Bound">v</a><a name="9008"> </a><a name="9009" href="#9009" class="Bound">e</a><a name="9010"> </a><a name="9011" class="Symbol">:</a><a name="9012"> </a><a name="9013" class="Datatype">ℕ</a><a name="9014" class="Symbol">}</a><a name="9015"> </a><a name="9016" class="Symbol">→</a><a name="9017"> </a><a name="9018" class="Function">Perm</a><a name="9022"> </a><a name="9023" class="Symbol">→</a><a name="9024"> </a><a name="9025" class="Datatype">Vec</a><a name="9028"> </a><a name="9029" class="Symbol">((</a><a name="9031" href="#6856" class="Datatype">Fin</a><a name="9034"> </a><a name="9035" href="#9007" class="Bound">v</a><a name="9036" class="Symbol">)</a><a name="9037"> </a><a name="9038" class="Function Operator">×</a><a name="9039"> </a><a name="9040" class="Symbol">(</a><a name="9041" href="#6856" class="Datatype">Fin</a><a name="9044"> </a><a name="9045" href="#9007" class="Bound">v</a><a name="9046" class="Symbol">))</a><a name="9048"> </a><a name="9049" href="#9009" class="Bound">e</a><a name="9050">
                              </a><a name="9081" class="Symbol">→</a><a name="9082"> </a><a name="9083" class="Datatype">Vec</a><a name="9086"> </a><a name="9087" class="Symbol">((</a><a name="9089" href="#6856" class="Datatype">Fin</a><a name="9092"> </a><a name="9093" href="#9007" class="Bound">v</a><a name="9094" class="Symbol">)</a><a name="9095"> </a><a name="9096" class="Function Operator">×</a><a name="9097"> </a><a name="9098" class="Symbol">(</a><a name="9099" href="#6856" class="Datatype">Fin</a><a name="9102"> </a><a name="9103" href="#9007" class="Bound">v</a><a name="9104" class="Symbol">))</a><a name="9106"> </a><a name="9107" href="#9009" class="Bound">e</a><a name="9108">
</a><a name="9109" href="#8993" class="Function">permActFin</a><a name="9119"> </a><a name="9120" class="InductiveConstructor">[]</a><a name="9122"> </a><a name="9123" href="#9123" class="Bound">v</a><a name="9124"> </a><a name="9125" class="Symbol">=</a><a name="9126"> </a><a name="9127" href="#9123" class="Bound">v</a><a name="9128">
</a><a name="9129" href="#8993" class="Function">permActFin</a><a name="9139"> </a><a name="9140" class="Symbol">((</a><a name="9142" href="#9142" class="Bound">a</a><a name="9143"> </a><a name="9144" class="InductiveConstructor Operator">,</a><a name="9145"> </a><a name="9146" href="#9146" class="Bound">b</a><a name="9147" class="Symbol">)</a><a name="9148"> </a><a name="9149" class="InductiveConstructor Operator">::</a><a name="9151"> </a><a name="9152" href="#9152" class="Bound">as</a><a name="9154" class="Symbol">)</a><a name="9155"> </a><a name="9156" href="#9156" class="Bound">v</a><a name="9157"> </a><a name="9158" class="Symbol">=</a><a name="9159"> </a><a name="9160" href="#8993" class="Function">permActFin</a><a name="9170"> </a><a name="9171" href="#9152" class="Bound">as</a><a name="9173"> </a><a name="9174" class="Symbol">(</a><a name="9175" href="#8541" class="Function">swapVecFin</a><a name="9185"> </a><a name="9186" href="#9142" class="Bound">a</a><a name="9187"> </a><a name="9188" href="#9146" class="Bound">b</a><a name="9189"> </a><a name="9190" href="#9156" class="Bound">v</a><a name="9191" class="Symbol">)</a><a name="9192">

</a><a name="9194" class="Keyword">data</a><a name="9198"> </a><a name="9199" href="#9199" class="Datatype">labelSwapEq</a><a name="9210"> </a><a name="9211" class="Symbol">:</a><a name="9212"> </a><a name="9213" class="Symbol">{</a><a name="9214" href="#9214" class="Bound">v</a><a name="9215"> </a><a name="9216" href="#9216" class="Bound">e</a><a name="9217"> </a><a name="9218" class="Symbol">:</a><a name="9219"> </a><a name="9220" class="Datatype">ℕ</a><a name="9221" class="Symbol">}</a><a name="9222"> </a><a name="9223" class="Symbol">→</a><a name="9224"> </a><a name="9225" class="Function">Rel</a><a name="9228"> </a><a name="9229" class="Symbol">(</a><a name="9230" class="Datatype">Vec</a><a name="9233"> </a><a name="9234" class="Symbol">((</a><a name="9236" href="#6856" class="Datatype">Fin</a><a name="9239"> </a><a name="9240" href="#9214" class="Bound">v</a><a name="9241" class="Symbol">)</a><a name="9242"> </a><a name="9243" class="Function Operator">×</a><a name="9244"> </a><a name="9245" class="Symbol">(</a><a name="9246" href="#6856" class="Datatype">Fin</a><a name="9249"> </a><a name="9250" href="#9214" class="Bound">v</a><a name="9251" class="Symbol">))</a><a name="9253"> </a><a name="9254" href="#9216" class="Bound">e</a><a name="9255" class="Symbol">)</a><a name="9256"> </a><a name="9257" class="Keyword">where</a><a name="9262">
  </a><a name="9265" href="#9265" class="InductiveConstructor">lSwapEq</a><a name="9272">  </a><a name="9274" class="Symbol">:</a><a name="9275"> </a><a name="9276" class="Symbol">{</a><a name="9277" href="#9277" class="Bound">v</a><a name="9278"> </a><a name="9279" href="#9279" class="Bound">e</a><a name="9280"> </a><a name="9281" class="Symbol">:</a><a name="9282"> </a><a name="9283" class="Datatype">ℕ</a><a name="9284" class="Symbol">}</a><a name="9285"> </a><a name="9286" class="Symbol">{</a><a name="9287" href="#9287" class="Bound">g</a><a name="9288"> </a><a name="9289" class="Symbol">:</a><a name="9290"> </a><a name="9291" class="Datatype">Vec</a><a name="9294"> </a><a name="9295" class="Symbol">((</a><a name="9297" href="#6856" class="Datatype">Fin</a><a name="9300"> </a><a name="9301" href="#9277" class="Bound">v</a><a name="9302" class="Symbol">)</a><a name="9303"> </a><a name="9304" class="Function Operator">×</a><a name="9305"> </a><a name="9306" class="Symbol">(</a><a name="9307" href="#6856" class="Datatype">Fin</a><a name="9310"> </a><a name="9311" href="#9277" class="Bound">v</a><a name="9312" class="Symbol">))</a><a name="9314"> </a><a name="9315" href="#9279" class="Bound">e</a><a name="9316" class="Symbol">}</a><a name="9317"> </a><a name="9318" class="Symbol">→</a><a name="9319"> </a><a name="9320" class="Symbol">(</a><a name="9321" href="#9321" class="Bound">a</a><a name="9322"> </a><a name="9323" href="#9323" class="Bound">b</a><a name="9324"> </a><a name="9325" class="Symbol">:</a><a name="9326"> </a><a name="9327" class="Datatype">Atom</a><a name="9331" class="Symbol">)</a><a name="9332">
             </a><a name="9346" class="Symbol">→</a><a name="9347"> </a><a name="9348" href="#9199" class="Datatype">labelSwapEq</a><a name="9359"> </a><a name="9360" class="Symbol">(</a><a name="9361" href="#8541" class="Function">swapVecFin</a><a name="9371"> </a><a name="9372" href="#9321" class="Bound">a</a><a name="9373"> </a><a name="9374" href="#9323" class="Bound">b</a><a name="9375"> </a><a name="9376" href="#9287" class="Bound">g</a><a name="9377" class="Symbol">)</a><a name="9378"> </a><a name="9379" href="#9287" class="Bound">g</a><a name="9380">
  </a><a name="9383" href="#9383" class="InductiveConstructor">lReflEq</a><a name="9390">  </a><a name="9392" class="Symbol">:</a><a name="9393"> </a><a name="9394" class="Symbol">{</a><a name="9395" href="#9395" class="Bound">v</a><a name="9396"> </a><a name="9397" href="#9397" class="Bound">e</a><a name="9398"> </a><a name="9399" class="Symbol">:</a><a name="9400"> </a><a name="9401" class="Datatype">ℕ</a><a name="9402" class="Symbol">}</a><a name="9403"> </a><a name="9404" class="Symbol">{</a><a name="9405" href="#9405" class="Bound">g</a><a name="9406"> </a><a name="9407" class="Symbol">:</a><a name="9408"> </a><a name="9409" class="Datatype">Vec</a><a name="9412"> </a><a name="9413" class="Symbol">((</a><a name="9415" href="#6856" class="Datatype">Fin</a><a name="9418"> </a><a name="9419" href="#9395" class="Bound">v</a><a name="9420" class="Symbol">)</a><a name="9421"> </a><a name="9422" class="Function Operator">×</a><a name="9423"> </a><a name="9424" class="Symbol">(</a><a name="9425" href="#6856" class="Datatype">Fin</a><a name="9428"> </a><a name="9429" href="#9395" class="Bound">v</a><a name="9430" class="Symbol">))</a><a name="9432"> </a><a name="9433" href="#9397" class="Bound">e</a><a name="9434" class="Symbol">}</a><a name="9435"> </a><a name="9436" class="Symbol">→</a><a name="9437"> </a><a name="9438" href="#9199" class="Datatype">labelSwapEq</a><a name="9449"> </a><a name="9450" href="#9405" class="Bound">g</a><a name="9451"> </a><a name="9452" href="#9405" class="Bound">g</a><a name="9453">
  </a><a name="9456" href="#9456" class="InductiveConstructor">lSymmEq</a><a name="9463">  </a><a name="9465" class="Symbol">:</a><a name="9466"> </a><a name="9467" class="Symbol">{</a><a name="9468" href="#9468" class="Bound">v</a><a name="9469"> </a><a name="9470" href="#9470" class="Bound">e</a><a name="9471"> </a><a name="9472" class="Symbol">:</a><a name="9473"> </a><a name="9474" class="Datatype">ℕ</a><a name="9475" class="Symbol">}</a><a name="9476"> </a><a name="9477" class="Symbol">{</a><a name="9478" href="#9478" class="Bound">g1</a><a name="9480"> </a><a name="9481" href="#9481" class="Bound">g2</a><a name="9483"> </a><a name="9484" class="Symbol">:</a><a name="9485"> </a><a name="9486" class="Datatype">Vec</a><a name="9489"> </a><a name="9490" class="Symbol">((</a><a name="9492" href="#6856" class="Datatype">Fin</a><a name="9495"> </a><a name="9496" href="#9468" class="Bound">v</a><a name="9497" class="Symbol">)</a><a name="9498"> </a><a name="9499" class="Function Operator">×</a><a name="9500"> </a><a name="9501" class="Symbol">(</a><a name="9502" href="#6856" class="Datatype">Fin</a><a name="9505"> </a><a name="9506" href="#9468" class="Bound">v</a><a name="9507" class="Symbol">))</a><a name="9509"> </a><a name="9510" href="#9470" class="Bound">e</a><a name="9511" class="Symbol">}</a><a name="9512"> </a><a name="9513" class="Symbol">→</a><a name="9514"> </a><a name="9515" href="#9199" class="Datatype">labelSwapEq</a><a name="9526"> </a><a name="9527" href="#9478" class="Bound">g1</a><a name="9529"> </a><a name="9530" href="#9481" class="Bound">g2</a><a name="9532">
             </a><a name="9546" class="Symbol">→</a><a name="9547"> </a><a name="9548" href="#9199" class="Datatype">labelSwapEq</a><a name="9559"> </a><a name="9560" href="#9481" class="Bound">g2</a><a name="9562"> </a><a name="9563" href="#9478" class="Bound">g1</a><a name="9565">
  </a><a name="9568" href="#9568" class="InductiveConstructor">lTransEq</a><a name="9576"> </a><a name="9577" class="Symbol">:</a><a name="9578"> </a><a name="9579" class="Symbol">{</a><a name="9580" href="#9580" class="Bound">v</a><a name="9581"> </a><a name="9582" href="#9582" class="Bound">e</a><a name="9583"> </a><a name="9584" class="Symbol">:</a><a name="9585"> </a><a name="9586" class="Datatype">ℕ</a><a name="9587" class="Symbol">}</a><a name="9588"> </a><a name="9589" class="Symbol">{</a><a name="9590" href="#9590" class="Bound">g1</a><a name="9592"> </a><a name="9593" href="#9593" class="Bound">g2</a><a name="9595"> </a><a name="9596" href="#9596" class="Bound">g3</a><a name="9598"> </a><a name="9599" class="Symbol">:</a><a name="9600"> </a><a name="9601" class="Datatype">Vec</a><a name="9604"> </a><a name="9605" class="Symbol">((</a><a name="9607" href="#6856" class="Datatype">Fin</a><a name="9610"> </a><a name="9611" href="#9580" class="Bound">v</a><a name="9612" class="Symbol">)</a><a name="9613"> </a><a name="9614" class="Function Operator">×</a><a name="9615"> </a><a name="9616" class="Symbol">(</a><a name="9617" href="#6856" class="Datatype">Fin</a><a name="9620"> </a><a name="9621" href="#9580" class="Bound">v</a><a name="9622" class="Symbol">))</a><a name="9624"> </a><a name="9625" href="#9582" class="Bound">e</a><a name="9626" class="Symbol">}</a><a name="9627"> </a><a name="9628" class="Symbol">→</a><a name="9629"> </a><a name="9630" href="#9199" class="Datatype">labelSwapEq</a><a name="9641"> </a><a name="9642" href="#9590" class="Bound">g1</a><a name="9644"> </a><a name="9645" href="#9593" class="Bound">g2</a><a name="9647">
             </a><a name="9661" class="Symbol">→</a><a name="9662"> </a><a name="9663" href="#9199" class="Datatype">labelSwapEq</a><a name="9674"> </a><a name="9675" href="#9593" class="Bound">g2</a><a name="9677"> </a><a name="9678" href="#9596" class="Bound">g3</a><a name="9680"> </a><a name="9681" class="Symbol">→</a><a name="9682"> </a><a name="9683" href="#9199" class="Datatype">labelSwapEq</a><a name="9694"> </a><a name="9695" href="#9590" class="Bound">g1</a><a name="9697"> </a><a name="9698" href="#9596" class="Bound">g3</a><a name="9700">

</a><a name="9702" href="#9702" class="Function">multiGraph₂</a><a name="9713"> </a><a name="9714" class="Symbol">:</a><a name="9715"> </a><a name="9716" class="Datatype">ℕ</a><a name="9717"> </a><a name="9718" class="Symbol">→</a><a name="9719"> </a><a name="9720" class="Datatype">ℕ</a><a name="9721"> </a><a name="9722" class="Symbol">→</a><a name="9723"> </a><a name="9724" href="#2040" class="Record">coNominal</a><a name="9733">
</a><a name="9734" href="#9702" class="Function">multiGraph₂</a><a name="9745"> </a><a name="9746" href="#9746" class="Bound">v</a><a name="9747"> </a><a name="9748" href="#9748" class="Bound">e</a><a name="9749"> </a><a name="9750" class="Symbol">=</a><a name="9751"> </a><a name="9752" class="Keyword">record</a><a name="9758"> </a><a name="9759" class="Symbol">{</a><a name="9760"> </a><a name="9761" class="Field">Aˢ</a><a name="9763"> </a><a name="9764" class="Symbol">=</a><a name="9765"> </a><a name="9766" class="Datatype">Vec</a><a name="9769"> </a><a name="9770" class="Symbol">((</a><a name="9772" href="#6856" class="Datatype">Fin</a><a name="9775"> </a><a name="9776" href="#9746" class="Bound">v</a><a name="9777" class="Symbol">)</a><a name="9778"> </a><a name="9779" class="Function Operator">×</a><a name="9780"> </a><a name="9781" class="Symbol">(</a><a name="9782" href="#6856" class="Datatype">Fin</a><a name="9785"> </a><a name="9786" href="#9746" class="Bound">v</a><a name="9787" class="Symbol">))</a><a name="9789"> </a><a name="9790" href="#9748" class="Bound">e</a><a name="9791">
                         </a><a name="9817" class="Symbol">;</a><a name="9818"> </a><a name="9819" class="Field">≈ᵃ</a><a name="9821"> </a><a name="9822" class="Symbol">=</a><a name="9823"> </a><a name="9824" href="#9199" class="Datatype">labelSwapEq</a><a name="9835">
                         </a><a name="9861" class="Symbol">;</a><a name="9862"> </a><a name="9863" class="Field">eq≈ᵃ</a><a name="9867"> </a><a name="9868" class="Symbol">=</a><a name="9869"> </a><a name="9870" class="Keyword">record</a><a name="9876"> </a><a name="9877" class="Symbol">{</a><a name="9878"> </a><a name="9879" class="Field">Reflex</a><a name="9885"> </a><a name="9886" class="Symbol">=</a><a name="9887"> </a><a name="9888" href="#9383" class="InductiveConstructor">lReflEq</a><a name="9895">
                                         </a><a name="9937" class="Symbol">;</a><a name="9938"> </a><a name="9939" class="Field">Symm</a><a name="9943"> </a><a name="9944" class="Symbol">=</a><a name="9945"> </a><a name="9946" href="#9456" class="InductiveConstructor">lSymmEq</a><a name="9953">
                                         </a><a name="9995" class="Symbol">;</a><a name="9996"> </a><a name="9997" class="Field">Trans</a><a name="10002"> </a><a name="10003" class="Symbol">=</a><a name="10004"> </a><a name="10005" href="#9568" class="InductiveConstructor">lTransEq</a><a name="10013"> </a><a name="10014" class="Symbol">}</a><a name="10015">
                         </a><a name="10041" class="Symbol">;</a><a name="10042"> </a><a name="10043" class="Field">coAct</a><a name="10048"> </a><a name="10049" class="Symbol">=</a><a name="10050"> </a><a name="10051" href="#8993" class="Function">permActFin</a><a name="10061">
                         </a><a name="10087" class="Symbol">;</a><a name="10088"> </a><a name="10089" class="Field">coRes</a><a name="10094"> </a><a name="10095" class="Symbol">=</a><a name="10096"> </a><a name="10097" class="Symbol">{!!}</a><a name="10101"> </a><a name="10102" class="Comment">-- annoying to prove, but definitely true</a><a name="10143">
                         </a><a name="10169" class="Symbol">;</a><a name="10170"> </a><a name="10171" class="Field">cop₁p₂↠</a><a name="10178"> </a><a name="10179" class="Symbol">=</a><a name="10180"> </a><a name="10181" class="Symbol">{!!}</a><a name="10185"> </a><a name="10186" class="Comment">-- annoying to prove, but definitely true</a><a name="10227">
                         </a><a name="10253" class="Symbol">;</a><a name="10254"> </a><a name="10255" class="Field">coι↠</a><a name="10259"> </a><a name="10260" class="Symbol">=</a><a name="10261"> </a><a name="10262" href="#9383" class="InductiveConstructor">lReflEq</a><a name="10269">

                         </a><a name="10296" class="Symbol">;</a><a name="10297"> </a><a name="10298" class="Field">coSupp</a><a name="10304"> </a><a name="10305" class="Symbol">=</a><a name="10306"> </a><a name="10307" class="Symbol">λ</a><a name="10308"> </a><a name="10309" href="#10309" class="Bound">_</a><a name="10310"> </a><a name="10311" class="Symbol">→</a><a name="10312"> </a><a name="10313" href="#7418" class="Function">coSuppFin</a><a name="10322"> </a><a name="10323" href="#9746" class="Bound">v</a><a name="10324">
                         </a><a name="10350" class="Symbol">;</a><a name="10351"> </a><a name="10352" class="Field">coSuppAx</a><a name="10360"> </a><a name="10361" class="Symbol">=</a><a name="10362"> </a><a name="10363" class="Symbol">λ</a><a name="10364"> </a><a name="10365" href="#10365" class="Bound">a</a><a name="10366"> </a><a name="10367" href="#10367" class="Bound">b</a><a name="10368"> </a><a name="10369" href="#10369" class="Bound">c</a><a name="10370"> </a><a name="10371" href="#10371" class="Bound">_</a><a name="10372"> </a><a name="10373" href="#10373" class="Bound">_</a><a name="10374"> </a><a name="10375" class="Symbol">→</a><a name="10376"> </a><a name="10377" href="#9265" class="InductiveConstructor">lSwapEq</a><a name="10384"> </a><a name="10385" href="#10367" class="Bound">b</a><a name="10386"> </a><a name="10387" href="#10369" class="Bound">c</a><a name="10388"> </a><a name="10389" class="Symbol">}</a></code></pre>
<p>Here, <code>multiGraph₂</code> is a coNominal set representing multigraphs, like before indexed by the number of nodes and edges; however, instead of equating all permutations of the edge set, all relabelings of the nodes of the graphs are equivalent. As there is no type constructor for coNominal sets in Agda, the sets we have defines are just terms. Thus, for the sake of simplicity of implimentation here, <code>multiGraph₂</code> is only defined over the type <code>Vec ((Fin v) × (Fin v)) e</code> (as opposed to ideally being defined over <code>multiGraph₁</code>). While we could do a deeper imbedding of the theory to allow a compositional structure for defining coNominal sets, it’d require a lot more work and would hardly be any more informative.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Choudhury, P. (2015). <a href="http://www.cl.cam.ac.uk/~amp12/agda/choudhury/choudhury-dissertation.pdf">Constructive Representation of Nominal Sets in Agda</a> (MPhil Thesis, University of Cambridge).<a href="#fnref1">↩</a></p></li>
</ol>
</div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
